# -*- coding: utf-8 -*-
"""PALLADIUM_CAR_STREAMLIT.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1kiarUd3WqN6Eu6vhsaQO22k14l2Tufnv
"""

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
import datetime
import plotly.express as px

"""#Carga dataset
Cargamos desde GOOGLE DRIVE el data set objeto de estudio

"""

# DESDE GOOGLE DRIVE
# Primero emparejamos Colab con Google Drive
from google.colab import drive
drive.mount('/content/drive')
# Importamos el archivos usando read_csv()
dir_archivo = '/content/drive/Shareddrives/Palladium/datasets/DATA_SET_RESERVAS_PALLADIUM_2021.csv'
df_r_= pd.read_csv(dir_archivo, sep=";")

"""Vamos a ver el aspecto inicial que tiene el df de Reservas 2021

"""

pd.options.display.max_rows=1000000
pd.options.display.max_columns=200

df_r_.columns

df_r_.head()

df_r_.tail()

df_r_.shape

df_r_.columns

"""#Limpieza variables y CAR
Eliminamos variables que no interesan, creamos agrupaciones, eliminamos filas del dataset que no son de interés

## Filtro CAR
Vamos a quedarnos sólo con las reservas de COD_CENTRAL= "CAR", esto es, las reservas en los hoteles de América Central de la cadena P.
"""

len(df_r_.loc[df_r_["COD_CENTRAL"]=="CAR"])

df_r_ = df_r_.loc[df_r_["COD_CENTRAL"]=="CAR",:]

df_r_.head()

df_r_.tail()

df_r_.shape

df_r_["COD_CENTRAL"].unique()    #lo hemos hecho bien....

"""## Eliminar variables
Tenemos en cuenta un conjunto de varibales de interés del data set
"""

filtro_variables=['ID_RESERVA', 'ID_HOTEL', 'COD_CENTRAL', 'LLEGADA', 'SALIDA', 'NOCHES',
       'REGIMEN', 'ID_TIPO', 'TIPO', 'USO', 'PAX', 'ADULTOS', 'NENES', 'BEBES',
       'TIPO_CLIENTE', 'CLIENTE', 'REPETIDOR', 'MANTENER_HIST', 'GRUPO', 'ID_MULTIPLE',
       'MULTIPLE', 'CONTRATO', 'MONEDA', 'TIPOFACTURA', 'STATUS', 'ID_MOTIVO',
       'HABITACION', 'ID_CARDEX', 'SUPLETORIA', 'CUNAS', 'LOC_COMPARTIDA',
       'GRUPOCARAC', 'ID_CUPO', 'FECHA_TOMA',
       'FECHA_MOD', 'FECHA_TTOO', 'SEGMENTO', 'FUENTE',
       'ATENCION', 'FIDELIDAD', 'NUMSOCIO', 'SEGMENTOCREDITO', 'ID_PAGO','TRATO', 'PAIS',
       'PAGO', 'VUELO', 'VALHAB', 'VALPEN', 'VALSERV', 'VALFIJOS',
       'COMERCIALIZADORA', 'CM_ID_CONTRATO', 'CM_CONTRATO', 'CMVALHAB',
       'CMVALPEN', 'CMCVALSERV', 'REGFACTURA', 'GRATIS', 'TIPOGRATIS',
       'VIAJACON', 'CUPO', 'TIPODOCUMENTO']

len(filtro_variables)

"""##Eliminar STATUS 9
Vamos a filtrar el data set, eliminando las filas en las que la columna "STATUS" es igual a 9 (Gustavo: problema de dupicidad de reservas...).
"""

len(df_r_[df_r_.STATUS==9])

df_r_.shape[0] - len(df_r_[df_r_.STATUS==9])

pd.options.display.max_columns=200
df_r_l = df_r_.loc[df_r_["STATUS"]!=9, filtro_variables]

df_r_l.shape

df_r_l.STATUS.unique()   #está bien hecho

df_r_l.head()

df_r_l.info()

"""##Eliminar GRUPO, PAGO, VUELO Y TIPOGRATIS Y GRUPOCARAC

"""

df_r_cl = df_r_l.drop(["GRUPO","PAGO","VUELO","TIPOGRATIS","GRUPOCARAC"], axis=1)

df_r_cl.shape

plt.figure(figsize=(50,50))
sns.heatmap(np.round(df_r_cl.corr(),2),
            vmin=-1, vmax=1,
            annot=True, cmap="coolwarm")
plt.show()

pd.options.display.max_columns=200
df_r_cl.dtypes

"""##Eliminar reservas gratis"""

len(df_r_cl[df_r_cl["GRATIS"]==1])

filtro_reservas_no_gratis = df_r_cl[df_r_cl["GRATIS"]!=1]
len(filtro_reservas_no_gratis)

filtro_reservas_no_gratis.iloc[0:4,:]

type(filtro_reservas_no_gratis)

filtro_reservas_no_gratis.shape

df_eda = filtro_reservas_no_gratis
df_eda.shape

df_eda.columns

"""##Variable CANCELACION
Será la variable Target de nuestro modelo de predicción. Si toma el valor cero significa que no se ha cancelado la reserva correspondiente, y viceversa si toma el valor 1
"""

df_eda['CANCELACION'] = pd.Series(dtype=np.int64)

df_eda.columns

df_eda.loc[(df_eda.STATUS==1),"CANCELACION"]= 0  #me daba error al usar en una sola condición con el simbolo |, por elloseparado..
df_eda.loc[(df_eda.STATUS==2),"CANCELACION"]= 0
df_eda.loc[(df_eda.STATUS==3),"CANCELACION"]=1
df_eda.loc[(df_eda.STATUS==4),"CANCELACION"]=1
df_eda.loc[(df_eda.STATUS==5),"CANCELACION"]=1

df_eda.head(2)

df_eda["CANCELACION"].dtype

df_eda["CANCELACION"] = df_eda["CANCELACION"].astype(np.int64)

df_eda.loc[(df_eda.STATUS==1 ),"CANCELACION"].unique()

df_eda.loc[(df_eda.STATUS==2),"CANCELACION"].unique()

df_eda.loc[(df_eda.STATUS==3 ),"CANCELACION"].unique()

df_eda.loc[(df_eda.STATUS==4),"CANCELACION"].unique()

df_eda.loc[(df_eda.STATUS==5),"CANCELACION"].unique()

df_eda["CANCELACION"].dtype

tabla_frec_CANCELACION = df_eda['CANCELACION'].value_counts().reset_index()
tabla_frec_CANCELACION.columns = ['CANCELACION', 'Frecuencia']
tabla_frec_CANCELACION

tabla_frec_CANCELACION_n = df_eda['CANCELACION'].value_counts(normalize=True).reset_index()

tabla_frec_CANCELACION_n.columns = ['CANCELACION', 'Frecuencia']
tabla_frec_CANCELACION_n["Frecuencia"] = tabla_frec_CANCELACION_n["Frecuencia"].map('{:.2%}'.format)
tabla_frec_CANCELACION_n      #no apreciamos un problema de desbalanceo de clases que podría afectarnos a la validez del modelo...

tabla_frec_CANCELACION_n = df_eda['CANCELACION'].value_counts(normalize=True).reset_index()
tabla_frec_CANCELACION_n
tabla_frec_CANCELACION_n.columns = ['CANCELACION', 'Frecuencia']
tabla_frec_CANCELACION_n

sns.set_theme(style="whitegrid")
ax=sns.barplot(data=tabla_frec_CANCELACION, x="CANCELACION", y="Frecuencia", errorbar="sd",orient="v")
#ax.set_yscale("log")
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.ylabel("Frecuencia")
plt.title('Distribución Cancelación reservas en Hoteles Cadena Palladium')

sns.set_theme(style="whitegrid")
ax= sns.barplot(tabla_frec_CANCELACION_n,  x= "CANCELACION", y = "Frecuencia", errorbar="sd",orient="v")
#ax.set_yscale("log")
plt.xticks(fontsize=12)
plt.yticks(fontsize=12)
plt.ylabel("Frecuencia relativa")
plt.title('Distribución Cancelación reservas en Hoteles Cadena Palladium')

"""#Análisis de variables
Vamos a analizar las variables una a una y mirar posibles relaciones
"""

df_eda.info()

df_eda.to_csv('df_eda_2021.csv',index=False, encoding='utf-8')  #no me hace el indice como una columna más de df

dir_archivo = '/content/df_eda_2021.csv'
df_r= pd.read_csv(dir_archivo)

df_r.head()

df_r.shape

#ID_RESERVA no se analiza, no tiene sentido

"""##ID_HOTEL"""

df_r.ID_HOTEL.value_counts().sort_values(ascending=False)    #frecuencias absolutas

df_r.ID_HOTEL.value_counts(normalize=True).sort_values(ascending=False)
df_r_ID_HOTEL = df_r.ID_HOTEL.value_counts(normalize=True).sort_values(ascending=False).map('{:.2%}'.format)
df_r_ID_HOTEL[0:10]
#aplicando .map('{:.2%}'.format) a la serie se obtienen los datos en formato porcentakje

df_r_.ID_HOTEL.unique()

df_r.ID_HOTEL.nunique()

serie_ID_HOTEL = df_r.ID_HOTEL.value_counts().sort_values(ascending=False)
serie_ID_HOTEL.values

serie_ID_HOTEL.index.sort_values(ascending=False)

tabla_frec_id_hotel = df_r['ID_HOTEL'].value_counts().reset_index()
tabla_frec_id_hotel.columns = ['ID_HOTEL', 'Frecuencia']
tabla_frec_id_hotel

tabla_frec_id_hotel_n = df_r['ID_HOTEL'].value_counts(normalize=True).reset_index()
tabla_frec_id_hotel_n.columns = ['ID_HOTEL', 'Frecuencia']


tabla_frec_id_hotel_n
tabla_frec_id_hotel_n["Frecuencia"]= tabla_frec_id_hotel_n["Frecuencia"].map('{:.2%}'.format)
tabla_frec_id_hotel_n

type(tabla_frec_id_hotel)

cross_C_H = pd.crosstab(df_r['ID_HOTEL'], df_r['CANCELACION'],normalize = False)
df_r["CANCELACION"].unique()

cross_C_H

cross_C_H_n= pd.crosstab(df_r['ID_HOTEL'], df_r['CANCELACION'], normalize = True)
cross_C_H_n

cross_C_H_n.columns

sns.set()
plt.bar(tabla_frec_id_hotel['ID_HOTEL'], tabla_frec_id_hotel['Frecuencia'])
plt.xlabel('ID_HOTEL')
plt.ylabel('Frecuencia')
plt.title('Distribución de ID_HOTEL')
plt.show()

sns.set_theme(style="whitegrid")
ax=sns.barplot(data=tabla_frec_id_hotel, x="ID_HOTEL", y="Frecuencia", errorbar="sd",orient="v")
ax.set_yscale("log")
plt.xticks(fontsize=10)
plt.yticks(fontsize=12)
plt.ylabel("Frecuencia")
plt.title('Distribución reservas en Hoteles Cadena Palladium')

tabla_frec_id_hotel_n = df_r['ID_HOTEL'].value_counts(normalize=True).reset_index()
tabla_frec_id_hotel_n.columns = ['ID_HOTEL', 'Frecuencia_relativa']


tabla_frec_id_hotel_n

sns.set_theme(style="whitegrid")
ax = sns.barplot(data = tabla_frec_id_hotel_n, x ="ID_HOTEL", y = "Frecuencia_relativa", orient="v", errorbar="sd")
#ax.set_yscale("log")
plt.xticks(fontsize=10)
plt.yticks(fontsize=12)
plt.title('Distribución reservas en Hoteles Cadena Palladium')

plt.figure(figsize=(20,20))
cross_C_H.plot(kind='bar', stacked=False)
plt.xlabel('ID_HOTEL')
plt.xticks(rotation=0, fontsize=10)
plt.ylabel('Frecuencia')
plt.title('Ditribucion de reservas efectivas/canceladas por hotel')
plt.show()

plt.figure(figsize=(20,20))
cross_C_H_n.plot(kind='bar', stacked=False)
plt.xlabel('ID_HOTEL')
plt.xticks(rotation=0, fontsize=10)
plt.ylabel('Frecuencia relativa')
plt.title('Ditribucion de reservas efectivas/canceladas por hotel')
plt.show()

"""##Ranking
Vamos a hacer un ranking de hoteles para simplificar esta variable y convertirla en categorica  
"""

top_ID_hoteles = df_r['ID_HOTEL'].value_counts().nlargest(6).index.tolist() #Creo que una lista de 6 hoteles top

df_r['TOP_6_HOTELES'] = df_r['ID_HOTEL'].apply(lambda x: x if x in top_ID_hoteles else 'Otros') #Creo nueva columna que se compone del nombre de los top hoteles, el resto como OTROS

df_r.loc[0:80,["ID_HOTEL","TOP_6_HOTELES"]]

df_r.TOP_6_HOTELES.value_counts(ascending=False)

"""106	Complejo Riviera Maya
107	Complejo Punta Cana
6	Palladium Vallarta
92	Grand Palladium Jamaica & Lady Hamilton Resort
83	Grand Palladium Imbassai Resort & Spa
96	Complejo Costa Mujeres
"""

type(df_r.TOP_6_HOTELES)

df_r.TOP_6_HOTELES.values[0:100]

def asignar_nombre_TOP_6_HOTELES(TOP_6_HOTELES):
    if TOP_6_HOTELES == 106:
        return "C.Riviera_Maya"
    elif TOP_6_HOTELES == 107:
        return "C.Punta_Cana"
    elif TOP_6_HOTELES == 96:
        return "C.Costa_Mujeres"
    elif TOP_6_HOTELES == 92:
        return "G.P._Jamaica"
    elif TOP_6_HOTELES == 83:
      return "G.P._Imb._R&SPA"
    elif TOP_6_HOTELES == 6:
      return "P.Vallarta"
    else:
      return "Otros"

df_r["TOP_6_NAMES_HOTELS"] = df_r["TOP_6_HOTELES"].apply(asignar_nombre_TOP_6_HOTELES)

df_r["TOP_6_NAMES_HOTELS"].unique()

tabla_frec_top_6_hotels = df_r['TOP_6_NAMES_HOTELS'].value_counts().reset_index()
tabla_frec_top_6_hotels.columns = ['TOP_6_NAMES_HOTELS', 'Frecuencia']
tabla_frec_top_6_hotels

tabla_frec_top_6_hotels_n = df_r['TOP_6_NAMES_HOTELS'].value_counts(normalize=True).reset_index()
tabla_frec_top_6_hotels_n.columns = ['TOP_6_NAMES_HOTELS', 'Frecuencia']
tabla_frec_top_6_hotels_n

cross_C_H_Name= pd.crosstab(df_r['TOP_6_NAMES_HOTELS'], df_r['CANCELACION'],normalize = False)
cross_C_H_Name

cross_C_H_Name_n= pd.crosstab(df_r['TOP_6_NAMES_HOTELS'], df_r['CANCELACION'],normalize = True)
cross_C_H_Name_n

sns.set_theme(style="whitegrid")
ax=sns.barplot(data=tabla_frec_top_6_hotels, x="TOP_6_NAMES_HOTELS", y="Frecuencia", errorbar="sd",orient="v")
#ax.set_yscale("log")
plt.xticks(fontsize=10, rotation=90)
plt.yticks(fontsize=12)
plt.ylabel("Frecuencia")
plt.title('Distribución reservas en Hoteles Cadena Palladium')

sns.set_theme(style="whitegrid")
ax=sns.barplot(data=tabla_frec_top_6_hotels_n, x="TOP_6_NAMES_HOTELS", y="Frecuencia", errorbar="sd",orient="v")
#ax.set_yscale("log")
plt.ylabel("Frecuencia relativa")
plt.xticks(fontsize=10, rotation=90)
plt.yticks(fontsize=12)
plt.title('Distribución reservas en Hoteles Cadena Palladium')

plt.figure(figsize=(20,20))
cross_C_H_Name.plot(kind='bar', stacked=False)
plt.xlabel('TOP_6_NAMES_HOTELS')
plt.xticks(rotation=90, fontsize=10)
plt.ylabel('Frecuencia')
plt.title('Ditribucion de reservas efectivas/canceladas por hotel')
plt.show()

plt.figure(figsize=(20,20))
cross_C_H_Name_n.plot(kind='bar', stacked=False)
plt.xlabel('TOP_6_NAMES_HOTELS')
plt.xticks(rotation=90, fontsize=10)
plt.ylabel('Frecuencia relativa')
plt.title('Ditribucion de reservas efectivas/canceladas por hotel')
plt.show()

df_r.head()

"""##LLEGADA Y SALIDA
Pasamos a formato de fecha. Creamos campo tipo mes año de ambos para que sea más sencillo visualizar después
"""

df_r['LLEGADA'] = pd.to_datetime(df_r['LLEGADA'])  # Convertir la columna a tipo datetime, he seguido lo mismo que has hecho tú
df_r['SALIDA'] = pd.to_datetime(df_r['SALIDA'])

df_r["LLEGADA"].dtype,df_r["SALIDA"].dtype

df_r["SALIDA"].dtype,df_r["SALIDA"].dtype

df_r.head()

df_r['LLEGADA_MES_ANYO'] = df_r['LLEGADA'].dt.strftime('%B %Y')  # Obtener el formato mes año (%B es el nombre del mes)
df_r['SALIDA_MES_ANYO'] = df_r['SALIDA'].dt.strftime('%B %Y')

df_r['LLEGADA_MES'] = df_r['LLEGADA'].dt.strftime('%B')  # Obtener el formato mes año (%B es el nombre del mes)
df_r['SALIDA_MES'] = df_r['SALIDA'].dt.strftime('%B')

df_r["LLEGADA_MES"].value_counts()

tabla_frec_LLEGADA = df_r['LLEGADA_MES'].value_counts().sort_values(ascending=False).reset_index()


tabla_frec_LLEGADA.columns = ['LLEGADA_MES', 'Frecuencia']
tabla_frec_LLEGADA

tabla_frec_LLEGADA_n = df_r['LLEGADA_MES'].value_counts(normalize=True).sort_values(ascending=False).reset_index()


tabla_frec_LLEGADA_n.columns = ['LLEGADA_MES', 'Frecuencia']
tabla_frec_LLEGADA_n

sns.set()
plt.bar(tabla_frec_LLEGADA['LLEGADA_MES'], tabla_frec_LLEGADA['Frecuencia'])
plt.tick_params(axis='both', labelsize=10)
plt.xlabel('LLEGADA_MES')
plt.xticks(rotation=90)
plt.ylabel('Frecuencia')
plt.title('Distribución de LLEGADA')
plt.show()

sns.set()
plt.bar(tabla_frec_LLEGADA_n['LLEGADA_MES'], tabla_frec_LLEGADA_n['Frecuencia'])
plt.tick_params(axis='both', labelsize=10)
plt.xlabel('LLEGADA_MES_ANYO')
plt.xticks(rotation=90)
plt.ylabel('Frecuencia relativa')
plt.title('Distribución de LLEGADA')
plt.show()

cross_C_LL = pd.crosstab(index= df_r['LLEGADA_MES'], columns= df_r['CANCELACION'],normalize = False)
cross_C_LL

cross_C_LL_n = pd.crosstab(index= df_r['LLEGADA_MES'], columns= df_r['CANCELACION'],normalize = True)
cross_C_LL_n

plt.figure(figsize=(20,20))
cross_C_LL.plot(kind='bar', stacked=False)
plt.xlabel('MES_LLEGADAS')
plt.xticks(rotation=90, fontsize=12)
plt.ylabel('Frecuencia')
plt.title('Ditribucion de reservas efectivas/canceladas por hotel')
plt.show()

plt.figure(figsize=(20,20))
cross_C_LL_n.plot(kind='bar', stacked=False)
plt.xlabel('MES_LLEGADAS')
plt.xticks(rotation=90, fontsize=12)
plt.ylabel('Frecuencia relativa')
plt.title('Ditribucion de reservas efectivas/canceladas por hotel')
plt.show()

df_r['SALIDA_MES'].value_counts().sort_values(ascending=False)

tabla_frec_SALIDA = df_r['SALIDA_MES'].value_counts().reset_index()
tabla_frec_SALIDA.columns = ['SALIDA_MES', 'Frecuencia']
tabla_frec_SALIDA

tabla_frec_SALIDA_n = df_r['SALIDA_MES'].value_counts(normalize=True).reset_index()
tabla_frec_SALIDA_n.columns = ['SALIDA_MES', 'Frecuencia']
tabla_frec_SALIDA_n

sns.set()
plt.bar(tabla_frec_SALIDA['SALIDA_MES'], tabla_frec_SALIDA['Frecuencia'])
plt.tick_params(axis='both', labelsize=10)
plt.xlabel('SALIDA_MES_ANYO')
plt.xticks(rotation=90)
plt.ylabel('Frecuencia')
plt.title('Distribución de SALIDA')
plt.show()

sns.set()
plt.bar(tabla_frec_SALIDA_n['SALIDA_MES'], tabla_frec_SALIDA_n['Frecuencia'])
plt.tick_params(axis='both', labelsize=10)
plt.xlabel('SALIDA_MES_ANYO')
plt.xticks(rotation=90)
plt.ylabel('Frecuencia relativa')
plt.title('Distribución de SALIDA')
plt.show()

cross_C_S = pd.crosstab(index= df_r['SALIDA_MES'], columns= df_r['CANCELACION'],normalize = False)
cross_C_S

cross_C_S_n = pd.crosstab(index= df_r['SALIDA_MES'], columns= df_r['CANCELACION'],normalize = True)
cross_C_S_n

plt.figure(figsize=(20,20))
cross_C_S.plot(kind='bar', stacked=False)
plt.xlabel('MES_SALIDAS')
plt.xticks(rotation=90, fontsize=12)
plt.ylabel('Frecuencia')
plt.title('Ditribucion de reservas efectivas/canceladas por hotel')
plt.show()

plt.figure(figsize=(20,20))
cross_C_S_n.plot(kind='bar', stacked=False)
plt.xlabel('MES_SALIDAS')
plt.xticks(rotation=90, fontsize=10)
plt.ylabel('Frecuencia relativa')
plt.title('Ditribucion de reservadas efectivas/canceladas por hotel')
plt.show()

"""##NOCHES
Analizar la frecuencia de noches.
Eliminar 0 noches y más de 30 *noches*
"""

serie_NOCHES = df_r.NOCHES.value_counts()
serie_NOCHES

serie_NOCHES_n= df_r.NOCHES.value_counts(normalize=True).sort_values(ascending=False)
serie_NOCHES_n.map('{:.2%}'.format)

df_r.NOCHES.nunique()

df_r.NOCHES.unique()

tabla_frec_NOCHES = df_r['NOCHES'].value_counts().reset_index()
tabla_frec_NOCHES.columns = ['NOCHES', 'Frecuencia']
tabla_frec_NOCHES

import plotly.express as px

fig = px.box(df_r, y="NOCHES")
fig.show()

import plotly.express as px

fig = px.box(df_r, y="NOCHES", x="CANCELACION")
fig.show()

tabla_frec_NOCHES.loc[0:14,:]   #noches con freq absoluta >1000
tabla_NOCHES_visual= tabla_frec_NOCHES.loc[0:14,:]
tabla_NOCHES_visual.columns

sns.set()
plt.bar(tabla_NOCHES_visual['NOCHES'], tabla_NOCHES_visual['Frecuencia'])
plt.tick_params(axis='both', labelsize=10)
plt.xlabel('NOCHES')
plt.xticks([1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20],rotation=0)
plt.ylabel('Frecuencia')
plt.yticks([1000,15000,35000,50000,80000,100000,115000])
plt.title('Distribución de NOCHES')
plt.show()

"""##Limpieza noches
Vamos a limpiar la variable NOCHE, eliminando noches con valor cero y número de noches mayor que 30
"""

len(df_r[df_r.NOCHES==0])

df_r.shape[0]

len(df_r) - len(df_r[df_r.NOCHES==0])

df_r = df_r[df_r['NOCHES'] != 0]

len(df_r)

len(df_r[df_r.NOCHES > 30])

len(df_r) -len (df_r[df_r.NOCHES > 30])

df_r = df_r[(df_r['NOCHES'] <= 30) & (df_r["NOCHES"]>0)]
df_r.shape

df_r.loc[(df_r["NOCHES"]==0) | (df_r["NOCHES"]>30),:]   #lógico que no existan...

condiciones = [                              #estamos convirtiendo una variable numerica en una variable categórica...
              (df_r.NOCHES>0) & (df_r.NOCHES<=2),
              (df_r.NOCHES>2) & (df_r.NOCHES<=7),
             (df_r.NOCHES>7) & (df_r.NOCHES<=15),
             (df_r.NOCHES>15) & (df_r.NOCHES<=30)
              ]

intervalo = ['entre_1_y_2','entre_3_y_7',
            'entre_8_y_15','entre_16_y_30']

df_r['NOCHES_AGRUPADAS'] = np.select(condiciones, intervalo)     #lo hizo así J. G. en la clase de outliers.....y funciona!!!!

df_r["NOCHES_AGRUPADAS"].value_counts()

df_r["NOCHES_AGRUPADAS"].value_counts().sum()

tabla_frec_NOCHES_AGR = df_r['NOCHES_AGRUPADAS'].value_counts().reset_index()
tabla_frec_NOCHES_AGR.columns = ['NOCHES', 'Frecuencia']
tabla_frec_NOCHES_AGR

tabla_frec_NOCHES_AGR_n = df_r['NOCHES_AGRUPADAS'].value_counts(normalize=True).reset_index()
tabla_frec_NOCHES_AGR_n.columns = ['NOCHES', 'Frecuencia']
tabla_frec_NOCHES_AGR_n

df_r.head()

cross_N_AGR_C = pd.crosstab(df_r['NOCHES_AGRUPADAS'], df_r['CANCELACION'],normalize = False)
cross_N_AGR_C

cross_N_AGR_C_n = pd.crosstab(df_r['NOCHES_AGRUPADAS'], df_r['CANCELACION'],normalize = True)
cross_N_AGR_C_n

sns.set()
plt.bar(tabla_frec_NOCHES_AGR['NOCHES'], tabla_frec_NOCHES_AGR['Frecuencia'])
plt.tick_params(axis='both', labelsize=10)
plt.xlabel('NOCHES_AGRUPADAS')
plt.xticks(rotation=45)
plt.ylabel('Frecuencia')
plt.title('Distribución de NOCHES_AGRUPADAS')
plt.show()

sns.set()
plt.bar(tabla_frec_NOCHES_AGR_n['NOCHES'], tabla_frec_NOCHES_AGR_n['Frecuencia'])
plt.tick_params(axis='both', labelsize=10)
plt.xlabel('NOCHES_AGRUPADAS')
plt.xticks(rotation=45)
plt.ylabel('Frecuencia relativa')
plt.title('Distribución de NOCHES_AGRUPADAS')
plt.show()

cross_N_AGR_C = pd.crosstab(index= df_r['NOCHES_AGRUPADAS'], columns= df_r['CANCELACION'],normalize = False)
cross_N_AGR_C

cross_N_AGR_C_n = pd.crosstab(index= df_r['NOCHES_AGRUPADAS'], columns= df_r['CANCELACION'],normalize = True)
cross_N_AGR_C_n

plt.figure(figsize=(20,20))
cross_N_AGR_C.plot(kind='bar', stacked=False)
plt.xlabel('NOCHES_AGRUPADAS')
plt.xticks(rotation=45, fontsize=10)
plt.ylabel('Frecuencia')
plt.title('Ditribucion de reservas efectivas/canceladas por hotel')
plt.show()

plt.figure(figsize=(20,20))
cross_N_AGR_C_n.plot(kind='bar', stacked=False)
plt.xlabel('NOCHES_AGRUPADAS')
plt.xticks(rotation=45, fontsize=10)
plt.ylabel("Frecuencia relativa")
plt.title('Ditribucion de reservas efectivas/canceladas por hotel')
plt.show()

len(df_r[df_r.NOCHES==0])

len(df_r[df_r["NOCHES"]>30])

"""##REGIMEN"""

serie_REGIMEN = df_r.REGIMEN.value_counts(ascending=False)
serie_REGIMEN

serie_REGIMEN.index

serie_REGIMEN.values

tabla_frec_REGIMEN = df_r['REGIMEN'].value_counts().reset_index()
tabla_frec_REGIMEN.columns = ['REGIMEN', 'Frecuencia']
tabla_frec_REGIMEN

tabla_frec_REGIMEN_n = df_r['REGIMEN'].value_counts(normalize=True).reset_index()
tabla_frec_REGIMEN_n.columns = ['REGIMEN', 'Frecuencia']
tabla_frec_REGIMEN_n

sns.set()
colores=["blue","red","grey","orange","green", "yellow"]
plt.bar(tabla_frec_REGIMEN['REGIMEN'], tabla_frec_REGIMEN['Frecuencia']/100, color = colores)
plt.tick_params(axis='both', labelsize=10)
plt.xlabel('REGIMEN')
plt.xticks(rotation=90)
plt.ylabel('Frecuencia en miles')
plt.title('Distribución de REGIMEN')
plt.show()

sns.set()
colores=["blue","red","grey","orange","green", "yellow"]
plt.bar(tabla_frec_REGIMEN_n['REGIMEN'], tabla_frec_REGIMEN_n['Frecuencia'], color = colores)
plt.tick_params(axis='both', labelsize=10)
plt.xlabel('REGIMEN')
plt.xticks(rotation=90)
plt.ylabel('Frecuencia relativa')
plt.title('Distribución de REGIMEN')
plt.show()

cross_R_C_n = pd.crosstab(df_r['REGIMEN'], df_r['CANCELACION'],normalize = True)
cross_R_C_n

cross_R_C = pd.crosstab(df_r['REGIMEN'], df_r['CANCELACION'],normalize = False)
cross_R_C

plt.figure(figsize=(20,20))
cross_R_C.plot(kind='bar', stacked=False)

plt.xlabel('REGIMEN')
plt.xticks(rotation=90, fontsize=9)
plt.ylabel('Frecuencia')
plt.title('Ditribucion de reservas efectivas/canceladas por REGIMEN')
plt.show()

plt.figure(figsize=(20,20))
cross_R_C_n.plot(kind='bar', stacked=False)

plt.xlabel('REGIMEN')
plt.xticks(rotation=0, fontsize=9)
plt.ylabel('Frecuencia relativa')
plt.title('Ditribucion de reservas efectivas/canceladas por REGIMEN')
plt.show()

"""##TIPO"""

df_r.TIPO.unique()

df_r.TIPO.nunique()

df_r.TIPO.value_counts(normalize=True).sort_values(ascending=False)

df_r.TIPO.value_counts(normalize=False).sort_values(ascending=False)

#Pasamos a mayúsuculas todo
df_r['TIPO'] = df_r['TIPO'].str.upper()
df_r.head()

df_r.TIPO.value_counts(normalize=False).sort_values(ascending=False)

# Definimos las condiciones para cada grupo
conditions = [
    (df_r['TIPO'].isin(['A. DELUXE SILVER HRT', 'GAR DELUXE', 'DOBLE ESTANDAR', 'WI ESTANDAR', 'GAR DELUXE DOBLE', 'TRIPLE ESTANDAR', 'SUPERIOR', 'DELUXE', 'DELUXE', 'DELUXE', 'COL DELUXE GARDEN VIEW', 'TRS JUNIOR SUITE GV', 'JAM JUNIOR SUITE GV', 'PAL DELUXE GARDEN VIEW', 'PC DELUXE GARDEN VIEW', 'BAV JUNIOR SUITE GV', 'TRS JUNIOR SUITE GV/PV', 'DELUXE DOBLE', 'CMU JUNIOR SUITE GV', 'TRS JUNIOR SUITE GV', 'DELUXE', 'DOBLE ESTANDAR', 'INDIVIDUAL', 'A. DELUXE SILVER', 'DELUXE', 'DOBLE ESTANDAR', 'DOBLE ESTANDAR', 'INDIVIDUAL', 'PVR DELUXE GARDEN VIEW', 'SSA JUNIOR SUITE GV', 'CAP JUNIOR SUITE MV', 'CAP JUNIOR SUITE PS OV'])),
    (df_r['TIPO'].isin(['DELUXE VISTA MAR', 'B. DELUXE GOLD HRT', 'WI DELUXE', 'TOW SUPERIOR', 'JUNIOR SUITE ESTANDAR', 'DOBLE', 'KAN DELUXE GARDEN VIEW', 'DELUXE VISTA MAR', 'TRS JUNIOR SUITE PS', 'TRS JUNIOR SUITE PS', 'LH JUNIOR SUITE GV', 'SUITE DUCAL', 'INDIVIDUAL VISTA MAR', 'DOBLE ESTANDAR', 'DOBLE ESTANDAR VISTA MAR', 'CMU JUNIOR SUITE PS', 'PAL DELUXE BEACHFRONT', 'DELUXE DOBLE VM', 'DELUXE DOBLE PREMIUM VM', 'PC DELUXE POOLSIDE', 'DELUXE PREMIUM VISTA MAR', 'TRS JUNIOR SUITE OV', 'BAV JUNIOR SUITE BF', 'B. DELUXE GOLD', 'DELUXE TERRACE', 'DELUXE SEA VIEW', 'DOBLE ESTANDAR VISTA MAR', 'PVR DELUXE POV', 'SSA JUNIOR SUITE PS', 'CAP JUNIOR SUITE SW PS', 'CAP JUNIOR SUITE SW'])),
    (df_r['TIPO'].isin(['GAR JUNIOR SUITE', 'SUPERIOR SWIM UP', 'JUNIOR SUITE', 'SUITE ESTANDAR', 'C. DELUXE PLATINUM HRT', 'COL JUNIOR SUITE GV', 'SUITE VISTA MAR', 'JUNIOR SUITE', 'JUNIOR SUITE', 'JUNIOR SUITE', 'SUITE', 'BAV SUPERIOR JS GV', 'PC JUNIOR SUITE GV', 'TRS JUNIOR SUITE PS OV', 'TRS JUNIOR SUITE PS OV', 'STUDIO SUITE', 'C. DELUXE SWIM UP', 'CMU JUNIOR SUITE PS OV', 'PAL DELUXE BF POV', 'DOBLE ESTANDAR VISTA MAR', 'DELUXE SUPERIOR VISTA MAR', 'TRS JUNIOR SUITE BF', 'DELUXE VISTA MAR', 'LH JUNIOR SUITE BF', 'PVR DELUXE OCEAN VIEW', 'SSA PREMIUM JS GV', 'STUDIO SUITE SAVAGE', 'CAP SUITE POOLSIDE OV', 'CAP SUITE JT OV', 'WI DELUXE PV'])),
    (df_r['TIPO'].isin(['WI DELUXE SV', 'D. STUDIO SUITE SILVER HR', 'SUPERIOR PARTY VIEW', 'TRIPLE DELUXE', 'SUITE', 'DELUXE', 'DOBLE VISTA MAR LATERAL', 'TRS JUNIOR SUITE SWIM UP', 'DELUXE', 'KAN JUNIOR SUITE GV', 'JUNIOR SUITE', 'SUITE', 'PAL JUNIOR SUITE GV', 'TRS JS JACUZZI TERR PS', 'CMU JUNIOR SUITE BF', 'STUDIO SUITE SEA VIEW', 'TRS JUNIOR SUITE BF OV', 'JAM JUNIOR SUITE PS', 'BAV SUPERIOR JS BF', 'SUITE PREFERENCIAL', 'JUNIOR SUITE VISTA PISCIN', 'JUNIOR SUITE VISTA MAR', 'PC JUNIOR SUITE POOLSIDE', 'D. STUDIO SUITE SILVER', 'PVR DELUXE OFV', 'CAP AMBASSADOR ST PS OV'])),
    (df_r['TIPO'].isin(['E. STUDIO SUITE GOLD HRT', 'JUNIOR SUITE DELUXE', 'WI SUPERIOR', 'ROMANCE BUNGALOW', 'SUITE VISTA MAR', 'BUNGALOW', 'DOBLE EXECUTIVE', 'SUPERIOR PARTY ALL NIGHT', 'TRS JUNIOR SUITE PP GV', 'WS JUNIOR SUITE GV', 'JAM JUNIOR SUITE OFV', 'SUITE', 'PC LOFT SUITE GV', 'TRS ROMANCE SUITE PS', 'TRS LOFT SUITE JT', 'SUITE PREFERENCIAL ESPECI', 'E. STUDIO SUITE BEACH TER', 'SUITE', 'BAV SUPERIOR JS POV', 'CABAÑA', 'CMU JUNIOR SUITE BF OV', 'PAL JUNIOR SUITE BF', 'DOBLE VENTANA', 'PVR JUNIOR SUITE GV'])),
    (df_r['TIPO'].isin(['JUNIOR SUITE EXECUTIVE', 'SUITE DELUXE', 'WI DELUXE TERRACE', 'F. STUDIO SUITE PLAT. HRT', 'SUPERIOR STAGE VIEW', 'SUITE PRESIDENCIAL', 'DELUXE PREMIUM', 'TRS ROMANCE SUITE SW', 'BAV PREMIUM JS GV', 'PC LOFT FAMILY SUITE', 'TRS JUNIOR SUITE PP PS', 'COL JUNIOR SUITE PS', 'F. STUDIO SUITE GOLD', 'PAL JUNIOR SUITE BF OV', 'CMU FS JUNIOR SUI BF POV', 'JAM JUNIOR SUITE PS OV', 'SUITE SEA VIEW', 'TRS LOFT SUITE JT OV', 'PVR JUNIOR SUITE OV', 'SUITE SAVAGE', 'WI SUPERIOR PS'])),
    (df_r['TIPO'].isin(['SUPERIOR FRONT ROW', 'SUITE EXECUTIVE', 'G. ROCK SUITE GOLD HRT', 'TRS SUITE GARDEN VIEW', 'SUITE', 'PAL LOFT SUITE GV', 'TRS VILLA SUITE POOLSIDE', 'BAV ROMANCE SUITE GV', 'PC PREMIUM JS PS', 'WS JUNIOR SUITE BF', 'TRS JUNIOR SUITE SW', 'CMU JUNIOR SUITE SW BF', 'TRS LOFT SUITE BF OV', 'LH JUNIOR SUITE OV', 'BLESS YOUR SAVAGE MIND', 'BLESS YOUR MED SUITE', 'G. STUDIO SUITE PLATINUM', 'PVR SUITE POV'])),
    (df_r['TIPO'].isin(['H. ROCK SUITE PLATINUM HR', 'FASHION VICTIM ROOM', 'SUPERIOR', 'PRESIDENCIAL', 'TRS VILLA SUITE SWIM UP', 'WS SUITE GARDEN VIEW', 'BAV ROOFTOP JT JS', 'TRS SUITE POOLSIDE', 'CMU LOFT SUITE JT', 'PAL LOFT SUITE BF', 'BLESS YOUR PRESIDENTIAL S', 'H. STUDIO SUITE SWIM UP', 'TRS JUNIOR SUITE SW BF', 'BAV ROMANCE SUITE BF', 'LH JUNIOR SUITE BF OV', 'PVR FS JUNIOR SUITE GV'])),
    (df_r['TIPO'].isin(['SUITE ACH', 'WI DLX SFV', 'I. ROCK SUITE DIAMOND HRT', 'JAM SUITE GARDEN VIEW', 'BAV ROOFTOP JT ST', 'TRS JACUZZI TERR SUI BF', 'WS SUITE BEACHFRONT', 'TRS ST JACUZZI TERR PS', 'CMU FS JUNIOR SUITE BF', 'TRS JUNIOR SUITE SW BFOV', 'PAL LOFT SUITE BF POV', 'I. ROCK SUITE', 'PVR AMBASSADOR SUITE POV'])),
    (df_r['TIPO'].isin(['SUITE ACH STAGE VIEW', 'J. ROCK ROYALTY DELUXE', 'DELUXE JACUZZI', 'TRS AMBASSADOR SUITE', 'TRS SUITE PP GV', 'KAN ROMANCE VILLA SUI BF', 'PAL JUNIOR SUITE SW BF', 'BAV JUNIOR SUITE SW POV', 'TRS AMBASSADOR ST BF OV', 'LH SUITE GV', 'J. ROCK SUITE + SUPLEMENT', 'CMU JUNIOR SUITE BF POV', 'PVR SIGNATURE SUITE POV'])),
    (df_r['TIPO'].isin(['K. ROCK ROYALTY STUDIO SU', 'SUITE', 'JUNIOR SUITE', 'COL ROMANCE VILLA SUI PS', 'BAV AMBASSADOR SUITE POV', 'TRS SUITE PP PS', 'CMU AMBASSADOR ST BF', 'TRS AMBASSADOR ST SWBFOV', 'K. ROCK SUITE PLATINUM', 'LH SUITE BF'])),
    (df_r['TIPO'].isin(['L. ROCK ROYALTY SUITE', 'SUITE MASTER', 'SUITE STAGE VIEW', 'TRS ROMANCE BW BYTHE LAKE', 'WS ROMANCE BW BYTHE LAKE', 'BAV SIGNATURE SUITE POV', 'CMU FS LOFT SUITE JT', 'TRS SIGNATURE ST BF POV', 'L. ROCK SUITE DIAMOND', 'JAM SUITE OFV'])),
    (df_r['TIPO'].isin(['WI SUITE SFV', 'LL. ROCK STAR SUITE HRT', 'SUITE AY CARAMBA', 'TRS AMBASSADOR SUITE POV', 'COL AMBASSADOR SUITE PS', 'TRS SIGNATURE ST SWBFPOV', 'CMU FS LOFT SUITE JT OV', 'LH SUITE OV', 'M. ROCK SUITE LEGEND'])),
    (df_r['TIPO'].isin(['WI SUP ST SFV', 'SUITE PIONNER', 'KAN AMBASSADOR SUITE', 'N. ROCK STAR SUITE', 'LH SUITE BF POV', 'CMU FS LOFT SUITE JT POV'])),
    (df_r['TIPO'].isin(['SUITE BACKSTAGE', 'KAN RESIDENCE SUITE BF', 'CMU AMBASSADOR SW BF', 'LH SUITE BF OV'])),
    (df_r['TIPO'].isin(['THE SWIM UP SUITE', 'LH AMBASSADOR SUITE BFOV', 'CMU FS AMBASSADOR SUI BF'])),
    (df_r['TIPO'].isin(['SUITE OH MY GOD', 'SUITE SIZE DOES MATTER', 'LH ROMANCE VILLA ST OV', 'CMU SIGNATURE SW BF OV'])),
    (df_r['TIPO'].isin(['THE XPA SUITE', 'CMU RESIDENCE SUI BF POV'])),
    (df_r['TIPO'].isin(["LH SIGNATURE RESIDENCE", "SUITE I'M ON TOP OF T"])),

]

# Definimos los valores correspondientes a cada grupo (1 al 19)
values = [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 12, 0, 0, 0, 0, 0, 0, 0]

# Creamos la nueva columna con los grupos
df_r['TIPO_AGRUPADO'] = np.select(conditions, values, default=0)  # Usamos none para valores no asignados

# Ahora, la columna "TIPO_AGRUPADO" contendrá valores del 1 al 19 según la condición cumplida, o 0 para "Otros".

df_r.TIPO_AGRUPADO.value_counts().sort_values(ascending=False)

"""##TIPO agrupado categorica"""

df_r.TIPO.value_counts(normalize=False).sort_values(ascending=False)

# Definimos las condiciones para cada grupo
conditions = [
    (df_r['TIPO'].isin(['A. DELUXE SILVER HRT', 'GAR DELUXE', 'DOBLE ESTANDAR', 'WI ESTANDAR', 'GAR DELUXE DOBLE', 'TRIPLE ESTANDAR', 'SUPERIOR', 'DELUXE', 'DELUXE', 'DELUXE', 'COL DELUXE GARDEN VIEW', 'TRS JUNIOR SUITE GV', 'JAM JUNIOR SUITE GV', 'PAL DELUXE GARDEN VIEW', 'PC DELUXE GARDEN VIEW', 'BAV JUNIOR SUITE GV', 'TRS JUNIOR SUITE GV/PV', 'DELUXE DOBLE', 'CMU JUNIOR SUITE GV', 'TRS JUNIOR SUITE GV', 'DELUXE', 'DOBLE ESTANDAR', 'INDIVIDUAL', 'A. DELUXE SILVER', 'DELUXE', 'DOBLE ESTANDAR', 'DOBLE ESTANDAR', 'INDIVIDUAL', 'PVR DELUXE GARDEN VIEW', 'SSA JUNIOR SUITE GV', 'CAP JUNIOR SUITE MV', 'CAP JUNIOR SUITE PS OV'])),
    (df_r['TIPO'].isin(['DELUXE VISTA MAR', 'B. DELUXE GOLD HRT', 'WI DELUXE', 'TOW SUPERIOR', 'JUNIOR SUITE ESTANDAR', 'DOBLE', 'KAN DELUXE GARDEN VIEW', 'DELUXE VISTA MAR', 'TRS JUNIOR SUITE PS', 'TRS JUNIOR SUITE PS', 'LH JUNIOR SUITE GV', 'SUITE DUCAL', 'INDIVIDUAL VISTA MAR', 'DOBLE ESTANDAR', 'DOBLE ESTANDAR VISTA MAR', 'CMU JUNIOR SUITE PS', 'PAL DELUXE BEACHFRONT', 'DELUXE DOBLE VM', 'DELUXE DOBLE PREMIUM VM', 'PC DELUXE POOLSIDE', 'DELUXE PREMIUM VISTA MAR', 'TRS JUNIOR SUITE OV', 'BAV JUNIOR SUITE BF', 'B. DELUXE GOLD', 'DELUXE TERRACE', 'DELUXE SEA VIEW', 'DOBLE ESTANDAR VISTA MAR', 'PVR DELUXE POV', 'SSA JUNIOR SUITE PS', 'CAP JUNIOR SUITE SW PS', 'CAP JUNIOR SUITE SW'])),
    (df_r['TIPO'].isin(['GAR JUNIOR SUITE', 'SUPERIOR SWIM UP', 'JUNIOR SUITE', 'SUITE ESTANDAR', 'C. DELUXE PLATINUM HRT', 'COL JUNIOR SUITE GV', 'SUITE VISTA MAR', 'JUNIOR SUITE', 'JUNIOR SUITE', 'JUNIOR SUITE', 'SUITE', 'BAV SUPERIOR JS GV', 'PC JUNIOR SUITE GV', 'TRS JUNIOR SUITE PS OV', 'TRS JUNIOR SUITE PS OV', 'STUDIO SUITE', 'C. DELUXE SWIM UP', 'CMU JUNIOR SUITE PS OV', 'PAL DELUXE BF POV', 'DOBLE ESTANDAR VISTA MAR', 'DELUXE SUPERIOR VISTA MAR', 'TRS JUNIOR SUITE BF', 'DELUXE VISTA MAR', 'LH JUNIOR SUITE BF', 'PVR DELUXE OCEAN VIEW', 'SSA PREMIUM JS GV', 'STUDIO SUITE SAVAGE', 'CAP SUITE POOLSIDE OV', 'CAP SUITE JT OV', 'WI DELUXE PV'])),
    (df_r['TIPO'].isin(['WI DELUXE SV', 'D. STUDIO SUITE SILVER HR', 'SUPERIOR PARTY VIEW', 'TRIPLE DELUXE', 'SUITE', 'DELUXE', 'DOBLE VISTA MAR LATERAL', 'TRS JUNIOR SUITE SWIM UP', 'DELUXE', 'KAN JUNIOR SUITE GV', 'JUNIOR SUITE', 'SUITE', 'PAL JUNIOR SUITE GV', 'TRS JS JACUZZI TERR PS', 'CMU JUNIOR SUITE BF', 'STUDIO SUITE SEA VIEW', 'TRS JUNIOR SUITE BF OV', 'JAM JUNIOR SUITE PS', 'BAV SUPERIOR JS BF', 'SUITE PREFERENCIAL', 'JUNIOR SUITE VISTA PISCIN', 'JUNIOR SUITE VISTA MAR', 'PC JUNIOR SUITE POOLSIDE', 'D. STUDIO SUITE SILVER', 'PVR DELUXE OFV', 'CAP AMBASSADOR ST PS OV'])),
    (df_r['TIPO'].isin(['E. STUDIO SUITE GOLD HRT', 'JUNIOR SUITE DELUXE', 'WI SUPERIOR', 'ROMANCE BUNGALOW', 'SUITE VISTA MAR', 'BUNGALOW', 'DOBLE EXECUTIVE', 'SUPERIOR PARTY ALL NIGHT', 'TRS JUNIOR SUITE PP GV', 'WS JUNIOR SUITE GV', 'JAM JUNIOR SUITE OFV', 'SUITE', 'PC LOFT SUITE GV', 'TRS ROMANCE SUITE PS', 'TRS LOFT SUITE JT', 'SUITE PREFERENCIAL ESPECI', 'E. STUDIO SUITE BEACH TER', 'SUITE', 'BAV SUPERIOR JS POV', 'CABAÑA', 'CMU JUNIOR SUITE BF OV', 'PAL JUNIOR SUITE BF', 'DOBLE VENTANA', 'PVR JUNIOR SUITE GV'])),
    (df_r['TIPO'].isin(['JUNIOR SUITE EXECUTIVE', 'SUITE DELUXE', 'WI DELUXE TERRACE', 'F. STUDIO SUITE PLAT. HRT', 'SUPERIOR STAGE VIEW', 'SUITE PRESIDENCIAL', 'DELUXE PREMIUM', 'TRS ROMANCE SUITE SW', 'BAV PREMIUM JS GV', 'PC LOFT FAMILY SUITE', 'TRS JUNIOR SUITE PP PS', 'COL JUNIOR SUITE PS', 'F. STUDIO SUITE GOLD', 'PAL JUNIOR SUITE BF OV', 'CMU FS JUNIOR SUI BF POV', 'JAM JUNIOR SUITE PS OV', 'SUITE SEA VIEW', 'TRS LOFT SUITE JT OV', 'PVR JUNIOR SUITE OV', 'SUITE SAVAGE', 'WI SUPERIOR PS'])),
    (df_r['TIPO'].isin(['SUPERIOR FRONT ROW', 'SUITE EXECUTIVE', 'G. ROCK SUITE GOLD HRT', 'TRS SUITE GARDEN VIEW', 'SUITE', 'PAL LOFT SUITE GV', 'TRS VILLA SUITE POOLSIDE', 'BAV ROMANCE SUITE GV', 'PC PREMIUM JS PS', 'WS JUNIOR SUITE BF', 'TRS JUNIOR SUITE SW', 'CMU JUNIOR SUITE SW BF', 'TRS LOFT SUITE BF OV', 'LH JUNIOR SUITE OV', 'BLESS YOUR SAVAGE MIND', 'BLESS YOUR MED SUITE', 'G. STUDIO SUITE PLATINUM', 'PVR SUITE POV'])),
    (df_r['TIPO'].isin(['H. ROCK SUITE PLATINUM HR', 'FASHION VICTIM ROOM', 'SUPERIOR', 'PRESIDENCIAL', 'TRS VILLA SUITE SWIM UP', 'WS SUITE GARDEN VIEW', 'BAV ROOFTOP JT JS', 'TRS SUITE POOLSIDE', 'CMU LOFT SUITE JT', 'PAL LOFT SUITE BF', 'BLESS YOUR PRESIDENTIAL S', 'H. STUDIO SUITE SWIM UP', 'TRS JUNIOR SUITE SW BF', 'BAV ROMANCE SUITE BF', 'LH JUNIOR SUITE BF OV', 'PVR FS JUNIOR SUITE GV'])),
    (df_r['TIPO'].isin(['SUITE ACH', 'WI DLX SFV', 'I. ROCK SUITE DIAMOND HRT', 'JAM SUITE GARDEN VIEW', 'BAV ROOFTOP JT ST', 'TRS JACUZZI TERR SUI BF', 'WS SUITE BEACHFRONT', 'TRS ST JACUZZI TERR PS', 'CMU FS JUNIOR SUITE BF', 'TRS JUNIOR SUITE SW BFOV', 'PAL LOFT SUITE BF POV', 'I. ROCK SUITE', 'PVR AMBASSADOR SUITE POV'])),
    (df_r['TIPO'].isin(['SUITE ACH STAGE VIEW', 'J. ROCK ROYALTY DELUXE', 'DELUXE JACUZZI', 'TRS AMBASSADOR SUITE', 'TRS SUITE PP GV', 'KAN ROMANCE VILLA SUI BF', 'PAL JUNIOR SUITE SW BF', 'BAV JUNIOR SUITE SW POV', 'TRS AMBASSADOR ST BF OV', 'LH SUITE GV', 'J. ROCK SUITE + SUPLEMENT', 'CMU JUNIOR SUITE BF POV', 'PVR SIGNATURE SUITE POV'])),
    (df_r['TIPO'].isin(['K. ROCK ROYALTY STUDIO SU', 'SUITE', 'JUNIOR SUITE', 'COL ROMANCE VILLA SUI PS', 'BAV AMBASSADOR SUITE POV', 'TRS SUITE PP PS', 'CMU AMBASSADOR ST BF', 'TRS AMBASSADOR ST SWBFOV', 'K. ROCK SUITE PLATINUM', 'LH SUITE BF'])),
    (df_r['TIPO'].isin(['L. ROCK ROYALTY SUITE', 'SUITE MASTER', 'SUITE STAGE VIEW', 'TRS ROMANCE BW BYTHE LAKE', 'WS ROMANCE BW BYTHE LAKE', 'BAV SIGNATURE SUITE POV', 'CMU FS LOFT SUITE JT', 'TRS SIGNATURE ST BF POV', 'L. ROCK SUITE DIAMOND', 'JAM SUITE OFV'])),
    (df_r['TIPO'].isin(['WI SUITE SFV', 'LL. ROCK STAR SUITE HRT', 'SUITE AY CARAMBA', 'TRS AMBASSADOR SUITE POV', 'COL AMBASSADOR SUITE PS', 'TRS SIGNATURE ST SWBFPOV', 'CMU FS LOFT SUITE JT OV', 'LH SUITE OV', 'M. ROCK SUITE LEGEND'])),
    (df_r['TIPO'].isin(['WI SUP ST SFV', 'SUITE PIONNER', 'KAN AMBASSADOR SUITE', 'N. ROCK STAR SUITE', 'LH SUITE BF POV', 'CMU FS LOFT SUITE JT POV'])),
    (df_r['TIPO'].isin(['SUITE BACKSTAGE', 'KAN RESIDENCE SUITE BF', 'CMU AMBASSADOR SW BF', 'LH SUITE BF OV'])),
    (df_r['TIPO'].isin(['THE SWIM UP SUITE', 'LH AMBASSADOR SUITE BFOV', 'CMU FS AMBASSADOR SUI BF'])),
    (df_r['TIPO'].isin(['SUITE OH MY GOD', 'SUITE SIZE DOES MATTER', 'LH ROMANCE VILLA ST OV', 'CMU SIGNATURE SW BF OV'])),
    (df_r['TIPO'].isin(['THE XPA SUITE', 'CMU RESIDENCE SUI BF POV'])),
    (df_r['TIPO'].isin(["LH SIGNATURE RESIDENCE", "SUITE I'M ON TOP OF T"])),

]

# Definimos los valores correspondientes a cada grupo (1 al 19)
values = ['1', '2', '3', '4', '5', '6', '7', '8', '9', '-1', '-1', '-1', '-1', '-1', '-1', '-1', '-1', '-1', '-1']

# Creamos la nueva columna con los grupos
df_r['TIPO_AGRUPADO_CAT'] = np.select(conditions, values, default='0')  # Usamos none para valores no asignados

df_r.TIPO_AGRUPADO_CAT.value_counts().sort_values(ascending=False)

"""##USO"""

df_r.USO.value_counts().sort_values(ascending=False)

df_r.USO.unique()

tabla_frec_USO = df_r['USO'].value_counts().reset_index()
tabla_frec_USO.columns = ['USO', 'Frecuencia']
tabla_frec_USO

tabla_frec_USO_n = df_r['USO'].value_counts(normalize=True).reset_index()
tabla_frec_USO_n.columns = ['USO', 'Frecuencia']
tabla_frec_USO_n

"""##PAX"""

df_r.PAX.value_counts(ascending=False)    #numero de personas que tienen reserva

df_r.PAX.value_counts(normalize=True,ascending=False)

df_r.PAX.nunique()

tabla_frec_PAX = df_r['PAX'].value_counts().reset_index()
tabla_frec_PAX.columns = ['PAX', 'Frecuencia']
tabla_PAX= tabla_frec_PAX.sort_values("PAX")
tabla_PAX

tabla_frec_PAX_n = df_r['PAX'].value_counts(normalize=True).reset_index()
tabla_frec_PAX_n.columns = ['PAX', 'Frecuencia']
tabla_PAX_n = tabla_frec_PAX_n.sort_values("PAX")
tabla_PAX_n

sns.set()
ax=sns.barplot(x=tabla_PAX['PAX'], y=tabla_PAX['Frecuencia'], data=tabla_PAX)
#ax.set_yscale('log')
plt.tick_params(axis='both', labelsize=10)
plt.xlabel('PAX')
plt.xticks(rotation=0)
plt.ylabel('Frecuencia')
plt.title("Frecuencia número personas en reservas")

sns.set()
ax=sns.barplot(x=tabla_PAX_n['PAX'], y=tabla_PAX_n['Frecuencia'], data=tabla_PAX)
#ax.set_yscale('log')
plt.tick_params(axis='both', labelsize=10)
plt.xlabel('PAX')
plt.xticks(rotation=0)
plt.ylabel('Frecuencia relativa')
plt.title("Frecuencia número personas en reservas")

cross_P_C = pd.crosstab(df_r['PAX'], df_r['CANCELACION'],normalize = False)
cross_P_C

cross_P_C_n = pd.crosstab(df_r['PAX'], df_r['CANCELACION'],normalize = True)
cross_P_C_n

plt.figure(figsize=(20,20))
cross_P_C.plot(kind='bar', stacked=False)

plt.xlabel('PAX')
plt.xticks(rotation=0, fontsize=10)
plt.ylabel('Frecuencia')
plt.title('Ditribucion de reservas efectivas/canceladas por PAX')
plt.show()

plt.figure(figsize=(20,20))
cross_P_C_n.plot(kind='bar', stacked=False)

plt.xlabel('PAX')
plt.xticks(rotation=0, fontsize=10)
plt.ylabel('Frecuencia relativa')
plt.title('Ditribucion de reservas efectivas/canceladas por PAX')
plt.show()

fig = px.box(df_r, x="CANCELACION", y="PAX")
fig.show()

"""###ADULTOS"""

df_r.ADULTOS.value_counts(ascending=False)

df_r.ADULTOS.value_counts(ascending=False).sum()

df_r.ADULTOS.unique()

tabla_frec_ADULTOS = df_r['ADULTOS'].value_counts().reset_index()
tabla_frec_ADULTOS.columns = ['ADULTOS', 'Frecuencia']
tabla_ADULTOS= tabla_frec_ADULTOS.sort_values("ADULTOS")
tabla_ADULTOS

sns.set()
ax=sns.barplot(x=tabla_ADULTOS['ADULTOS'], y=tabla_ADULTOS['Frecuencia'], data=tabla_ADULTOS)
#ax.set_yscale('log')
plt.tick_params(axis='both', labelsize=10)
plt.xlabel('ADULTOS')
plt.xticks(rotation=0)
plt.ylabel('Frecuencia')
plt.title("Distribución número personas en reservas")

tabla_frec_ADULTOS_n = df_r['ADULTOS'].value_counts(normalize=True).reset_index()
tabla_frec_ADULTOS_n

tabla_frec_ADULTOS_n.columns = ['ADULTOS', 'Frecuencia']

tabla_frec_ADULTOS_n

sns.set()
ax=sns.barplot(x=tabla_frec_ADULTOS_n['ADULTOS'], y=tabla_frec_ADULTOS_n['Frecuencia'], data=tabla_frec_ADULTOS_n)
#ax.set_yscale('log')
plt.tick_params(axis='both', labelsize=10)
plt.xlabel('ADULTOS')
plt.xticks(rotation=0)
plt.ylabel('Frecuencia relativa')
plt.title("Distribución número personas en reservas")

"""###NENES"""

df_r.NENES.value_counts(ascending=False)

df_r.NENES.nunique()

tabla_frec_NENES = df_r['NENES'].value_counts().reset_index()
tabla_frec_NENES.columns = ['NENES', 'Frecuencia']
tabla_NENES= tabla_frec_NENES.sort_values("NENES")
tabla_NENES

sns.set()
ax=sns.barplot(x=tabla_NENES['NENES'], y=tabla_NENES['Frecuencia'], data=tabla_NENES)
#ax.set_yscale('log')
plt.tick_params(axis='both', labelsize=10)
plt.xlabel('NENES')
plt.xticks(rotation=0)
plt.ylabel('Frecuencia')
plt.title("Distribución nenes en reservas")

tabla_frec_NENES_n = df_r['NENES'].value_counts(normalize=True).reset_index()
tabla_frec_NENES_n.columns = ['NENES', 'Frecuencia']
tabla_NENES_n= tabla_frec_NENES_n.sort_values("NENES")
tabla_NENES_n

sns.set()
ax=sns.barplot(x=tabla_NENES_n['NENES'], y=tabla_NENES_n['Frecuencia'], data=tabla_NENES_n)
#ax.set_yscale('log')
plt.tick_params(axis='both', labelsize=10)
plt.xlabel('NENES')
plt.xticks(rotation=0)
plt.ylabel('Frecuencia relativa')
plt.title("Distribución nenes en reservas")

"""###BEBES"""

df_r.BEBES.value_counts().sort_values(ascending=False)

df_r.BEBES.unique()

df_r.BEBES.nunique()

tabla_frec_BEBES = df_r['BEBES'].value_counts().reset_index()
tabla_frec_BEBES.columns = ['BEBES', 'Frecuencia']
tabla_BEBES= tabla_frec_BEBES.sort_values("BEBES")
tabla_BEBES

sns.set()
ax=sns.barplot(x=tabla_BEBES['BEBES'], y=tabla_BEBES['Frecuencia'], data=tabla_BEBES)
#ax.set_yscale('log')
plt.tick_params(axis='both', labelsize=10)
plt.xlabel('BEBES')
plt.xticks(rotation=0)
plt.ylabel('Frecuencia')
plt.title("Distribución bebes en reservas")

tabla_frec_BEBES_n = df_r['BEBES'].value_counts(normalize=True).reset_index()
tabla_frec_BEBES_n.columns = ['BEBES', 'Frecuencia']
tabla_BEBES_n= tabla_frec_BEBES_n.sort_values("BEBES")
tabla_BEBES_n

sns.set()
ax=sns.barplot(x=tabla_BEBES_n['BEBES'], y=tabla_BEBES_n['Frecuencia'], data=tabla_BEBES_n)
#ax.set_yscale('log')
plt.tick_params(axis='both', labelsize=10)
plt.xlabel('BEBES')
plt.xticks(rotation=0)
plt.ylabel('Frecuencia relativa')
plt.title("Distribución bebes en reservas")



"""###TARGET"""

df_r["TARGET"]= "PAREJA"      #le doy a toda la columna ese valor por defecto, va a dar igual .....

df_r.loc[(df_r["ADULTOS"]==2) & (df_r["NENES"]==0) & (df_r["BEBES"]== 0), "TARGET"]= "PAREJA"


df_r.loc[df_r["ADULTOS"]==1  & (df_r["NENES"]==0) & (df_r["BEBES"]== 0), "TARGET"]= "INDIVIDUO"

df_r.loc[(df_r["ADULTOS"]!=1) & (df_r["ADULTOS"]!=2) & (df_r["ADULTOS"]!=0), "TARGET"]= "GRUPO"   #coincide con valores para los que no hay tipo_CLIENTE, supongo que habrá que eliminarlos...

df_r.loc[df_r["ADULTOS"]==0, "TARGET"]= "FAMILIA" #Excursiones fin de curso si hay nenes? Habitaciones compartidas


filtro_familia = df_r.loc[(df_r.ADULTOS==2) & ((df_r.NENES!=0) | (df_r["BEBES"]!=0))]


df_r.loc[((df_r.ADULTOS==2) | (df_r.ADULTOS==1)) & ((df_r.NENES!=0) | (df_r.BEBES!=0)),"TARGET"]= "FAMILIA"

#¿si hay más de dos adultos?...¿Nueva categoria?...preguntar Gustavo...
#¿Qué hacemos en los casos donde solo hay un adulto con bebes/nenes?

len(df_r.TARGET)      #ok, nos cuadra con las filas que tiene el df limpio...

df_r.shape

df_r.TARGET.unique()

df_r.TARGET.value_counts()

tabla_frec_TARGET = df_r['TARGET'].value_counts().reset_index()
tabla_frec_TARGET.columns = ['TARGET', 'Frecuencia']
tabla_TARGET = tabla_frec_TARGET.sort_values("TARGET")
tabla_TARGET

tabla_frec_TARGET_n = df_r['TARGET'].value_counts(normalize=True).reset_index()
tabla_frec_TARGET_n.columns = ['TARGET', 'Frecuencia']
tabla_TARGET_n = tabla_frec_TARGET_n.sort_values("TARGET")
tabla_TARGET_n

sns.set()
ax=sns.barplot(x=tabla_TARGET['TARGET'], y=tabla_TARGET['Frecuencia'], data=tabla_TARGET)
#ax.set_yscale('log')
plt.tick_params(axis='both', labelsize=10)
plt.xlabel('TARGET')
plt.xticks(rotation=0)
plt.ylabel('Frecuencia')
plt.title("Distribución target en reservas")

sns.set()
ax=sns.barplot(x=tabla_TARGET_n['TARGET'], y=tabla_TARGET_n['Frecuencia'], data=tabla_TARGET_n)
#ax.set_yscale('log')
plt.tick_params(axis='both', labelsize=10)
plt.xlabel('TARGET')
plt.xticks(rotation=0)
plt.ylabel('Frecuencia relativa')
plt.title("Distribución target en reservas")

cross_T_C = pd.crosstab(df_r['TARGET'], df_r['CANCELACION'],normalize = False)
cross_T_C

cross_T_C_n = pd.crosstab(df_r['TARGET'], df_r['CANCELACION'],normalize = True)
cross_T_C_n

plt.figure(figsize=(20,20))
cross_T_C.plot(kind='bar', stacked=False)

plt.xlabel('TARGET')
plt.xticks(rotation=0, fontsize=10)
plt.ylabel('Frecuencia')
plt.title('Ditribucion de reservas efectivas/canceladas por TARGET')
plt.show()

plt.figure(figsize=(20,20))
cross_T_C_n.plot(kind='bar', stacked=False)

plt.xlabel('TARGET')
plt.xticks(rotation=0, fontsize=10)
plt.ylabel('Frecuencia relativa')
plt.title('Ditribucion de reservas efectivas/canceladas por TARGET')
plt.show()

"""##FUNCION RAFA"""

#Intenté hacer una función para no repetir siempre lo mismo, pero creo que no funciona bien..

#import seaborn as sns
#import matplotlib.pyplot as plt
#import pandas as pd

#def EDA_variables (df):
#  for columna in df.columns:
 #   if (df[columna].dtype == 'int64') or (df.columna.dtype=="float64") or (df.columna.dtype=="object"):
  #      unique_valores= df[columna].unique()
   #     nunique_valores=df[columna].nunique()
    #    value_counts= df[columna].value_counts(ascending=False)
#
  #      tabla = df[columna].value_counts().reset_index()
 #       tabla.columns = [columna, "Frecuencia"]
#        ax=sns.barplot(x=tabla[columna], y=tabla['Frecuencia'], data=tabla)
 #       ax.set_yscale('log')
  #      #plt.tick_params(axis='both', labelsize=10)
   #     plt.xlabel(columna)
    #    plt.xticks(rotation=0)
     #   plt.ylabel('Frecuencia')
      #  plt.title("Distribución",columna, "en reservas")
       # return(tabla,ax,unique_valores,nunique_valores)

"""##TIPO CLIENTE"""

df_r.TIPO_CLIENTE.value_counts()

df_r.TIPO_CLIENTE.unique()

df_r.TIPO_CLIENTE.nunique()

tabla_frec_TIPO_CLIENTE = df_r['TIPO_CLIENTE'].value_counts().reset_index()
tabla_frec_TIPO_CLIENTE.columns = ['TIPO_CLIENTE', 'Frecuencia']

tabla_frec_TIPO_CLIENTE

tabla_frec_TIPO_CLIENTE_n = df_r['TIPO_CLIENTE'].value_counts(normalize=True).reset_index()
tabla_frec_TIPO_CLIENTE_n.columns = ['TIPO_CLIENTE', 'Frecuencia']

tabla_frec_TIPO_CLIENTE_n

ax=sns.barplot(x=tabla_frec_TIPO_CLIENTE["TIPO_CLIENTE"], y=tabla_frec_TIPO_CLIENTE['Frecuencia'], data=tabla_frec_TIPO_CLIENTE)
#ax.set_yscale('log')
plt.tick_params(axis='both', labelsize=10)
#plt.xlabel(tabla_frec_TIPO_CLIENTE["TIPO_CLIENTE"])
plt.xticks(rotation=0)
plt.ylabel('Frecuencia')
plt.title("Distribución TIPO_CIENTE en reservas")

ax=sns.barplot(x=tabla_frec_TIPO_CLIENTE_n["TIPO_CLIENTE"], y=tabla_frec_TIPO_CLIENTE_n['Frecuencia'], data=tabla_frec_TIPO_CLIENTE_n)
#ax.set_yscale('log')
plt.tick_params(axis='both', labelsize=10)
#plt.xlabel(tabla_frec_TIPO_CLIENTE["TIPO_CLIENTE"])
plt.xticks(rotation=0)
plt.ylabel('Frecuencia relativa')
plt.title("Distribución TIPO_CIENTE en reservas")

cross_CL_C_n = pd.crosstab(df_r['TIPO_CLIENTE'], df_r['CANCELACION'],normalize = True)
cross_CL_C_n

cross_CL_C = pd.crosstab(df_r['TIPO_CLIENTE'], df_r['CANCELACION'],normalize = False)
cross_CL_C

plt.figure(figsize=(20,20))
cross_CL_C.plot(kind='bar', stacked=False)

plt.xlabel('TIPO_CLIENTE')
plt.xticks(rotation=0, fontsize=10)
plt.ylabel('Frecuencia')
plt.title('Ditribucion de reservas efectivas/canceladas por TIPO_CLIENTE')
plt.show()

plt.figure(figsize=(20,20))
cross_CL_C_n.plot(kind='bar', stacked=False)

plt.xlabel('TIPO_CLIENTE')
plt.xticks(rotation=0, fontsize=7)
plt.ylabel('Frecuencia relativa')
plt.title('Ditribucion de reservas efectivas/canceladas por TIPO_CLIENTE')
plt.show()

"""## CAMPO CLIENTE"""

df_r.CLIENTE.value_counts()

df_r['CLIENTE'] = df_r['CLIENTE'].str.upper()
df_r.head(1)

"""##CLIENTE AGRUPADO"""

df_r['CLIENTE_AGRUPADO'] = df_r['CLIENTE']

# Definir condiciones y valores a asignar
conditions = [
    df_r['CLIENTE_AGRUPADO'].str.contains('ROIBACK', case=False),
    df_r['CLIENTE_AGRUPADO'].str.contains('CALL CENTER', case=False),
    df_r['CLIENTE_AGRUPADO'].str.contains('PALLADIUM TRAVEL CLUB', case=False),
    df_r['CLIENTE_AGRUPADO'].str.contains('EXPEDIA', case=False),
    df_r['CLIENTE_AGRUPADO'].str.contains('TRAVELPLAN', case=False),
    df_r['CLIENTE_AGRUPADO'].str.contains('APPLE VACATIONS', case=False),
    df_r['CLIENTE_AGRUPADO'].str.contains('TRAVEL IMPRESSIONS', case=False),
    df_r['CLIENTE_AGRUPADO'].str.contains('BOOKING.COM', case=False),
    df_r['CLIENTE_AGRUPADO'].str.contains('AGENT CONNECT PHG', case=False),
    df_r['CLIENTE_AGRUPADO'].str.contains('COMM GROUP / CHEAP CARIBBEAN', case=False),
    df_r['CLIENTE_AGRUPADO'].str.contains('TRAVEL AGENT', case=False),
]

values = ['ROIBACK', 'CALL CENTER', 'PALLADIUM TRAVEL CLUB', 'EXPEDIA', 'TRAVELPLAN', 'APPLE VACATIONS', 'TRAVEL IMPRESSIONS', 'BOOKING.COM','AGENT CONNECT PHG','COMM GROUP / CHEAP CARIBBEAN', 'TRAVEL AGENT']

# Convertir las condiciones a matrices booleanas explícitamente
boolean_conditions = [condition.astype(bool) for condition in conditions]

# Aplicar las condiciones usando numpy.select() y asignar el resultado a la columna 'CLIENTE_AGRUPADO'
df_r['CLIENTE_AGRUPADO'] = np.select(boolean_conditions, values, default=df_r['CLIENTE_AGRUPADO'])

df_r.head(2)

valores_recuentos = df_r['CLIENTE_AGRUPADO'].value_counts().sort_index()

print(valores_recuentos)

# Obtener las 30 primeras frecuencias
top_30_values = df_r['CLIENTE_AGRUPADO'].value_counts().head(30).index.tolist()

# Cambiar el valor de las frecuencias no incluidas en top 30 por 'OTROS'
df_r.loc[~df_r['CLIENTE_AGRUPADO'].isin(top_30_values), 'CLIENTE_AGRUPADO'] = 'OTROS'

print(df_r['CLIENTE_AGRUPADO'].value_counts())

"""##Creamos una nueva columna ORIGEN_CLIENTE"""

filtro_RESERVAS_DIRECTAS_CALLCENTER = df_r[df_r["CLIENTE"].str.contains("CALL CENTER", na=False)]
filtro_RESERVAS_DIRECTAS_ROIBACK = df_r[df_r["CLIENTE"].str.contains("ROIBACK", na=False)]

cantidad_RESERVAS_DIRECTAS_CALLCENTER = len(filtro_RESERVAS_DIRECTAS_CALLCENTER)
cantidad_RESERVAS_DIRECTAS_ROIBACK = len(filtro_RESERVAS_DIRECTAS_ROIBACK)

print("Total Reservas directas CALLCENTER", cantidad_RESERVAS_DIRECTAS_CALLCENTER)
print("Total Reservas directas ROIBACK", cantidad_RESERVAS_DIRECTAS_ROIBACK)

df_r["ORIGEN_CLIENTE"] ="TOUROPERADOR"


df_r.loc[(df_r["CLIENTE"].str.contains("CALL CENTER", na=False)) | (df_r["CLIENTE"].str.contains("ROIBACK", na=False)),"ORIGEN_CLIENTE"]="VENTA_DIRECTA"

len(df_r[(df_r["CLIENTE"].str.contains("CALL CENTER", na=False)) | (df_r["CLIENTE"].str.contains("ROIBACK", na=False))])

len(df_r.loc[df_r["ORIGEN_CLIENTE"]=="VENTA_DIRECTA"])

len(df_r.loc[df_r["ORIGEN_CLIENTE"]=="TOUROPERADOR"])

len(df_r.loc[df_r["ORIGEN_CLIENTE"]=="VENTA_DIRECTA"]) + len(df_r.loc[df_r["ORIGEN_CLIENTE"]=="TOUROPERADOR"])

df_r.shape[0]

df_r.columns

df_r["ORIGEN_CLIENTE"].unique()

df_r["ORIGEN_CLIENTE"].value_counts()     #pendiente el EDA de esta nueva variable......

tabla_frec_ORIGEN_CLIENTE = df_r['ORIGEN_CLIENTE'].value_counts().reset_index()
tabla_frec_ORIGEN_CLIENTE.columns = ['ORIGEN_CLIENTE', 'Frecuencia']
tabla_ORIGEN_CLIENTE= tabla_frec_ORIGEN_CLIENTE.sort_values("ORIGEN_CLIENTE")
tabla_ORIGEN_CLIENTE

tabla_frec_ORIGEN_CLIENTE_n = df_r['ORIGEN_CLIENTE'].value_counts(normalize=True).reset_index()
tabla_frec_ORIGEN_CLIENTE_n.columns = ['ORIGEN_CLIENTE', 'Frecuencia']
tabla_ORIGEN_CLIENTE_n= tabla_frec_ORIGEN_CLIENTE_n.sort_values("ORIGEN_CLIENTE")
tabla_ORIGEN_CLIENTE_n

sns.set()
plt.bar(tabla_frec_ORIGEN_CLIENTE['ORIGEN_CLIENTE'], tabla_frec_ORIGEN_CLIENTE['Frecuencia'])
plt.tick_params(axis='both', labelsize=10)
plt.xlabel('ORIGEN_CLIENTE')
plt.xticks(rotation=0)
plt.ylabel('Frecuencia')
plt.title('Distribución de ORIGEN_CLIENTE')
plt.show()

sns.set()
plt.bar(tabla_frec_ORIGEN_CLIENTE_n['ORIGEN_CLIENTE'], tabla_frec_ORIGEN_CLIENTE_n['Frecuencia'])
plt.tick_params(axis='both', labelsize=10)
plt.xlabel('ORIGEN_CLIENTE')
plt.xticks(rotation=0)
plt.ylabel('Frecuencia relativa')
plt.title('Distribución de ORIGEN_CLIENTE')
plt.show()

cross_OC_C_n = pd.crosstab(df_r['ORIGEN_CLIENTE'], df_r['CANCELACION'],normalize = True)
cross_OC_C_n

cross_OC_C = pd.crosstab(df_r['ORIGEN_CLIENTE'], df_r['CANCELACION'],normalize = False)
cross_OC_C

plt.figure(figsize=(20,20))
cross_OC_C_n.plot(kind='bar', stacked=False)

plt.xlabel('ORIGEN_CLIENTE')
plt.xticks(rotation=0, fontsize=10)
plt.ylabel('Frecuencia relativa')
plt.title('Ditribucion de reservas efectivas/canceladas por ORIGEN_CLIENTE')
plt.show()

plt.figure(figsize=(20,20))
cross_OC_C.plot(kind='bar', stacked=False)

plt.xlabel('ORIGEN_CLIENTE')
plt.xticks(rotation=0, fontsize=10)
plt.ylabel(' Frecuencia')
plt.title('Ditribucion de reservas efectivas/canceladas por ORIGEN_CLIENTE')
plt.show()

df_r.head(20)

"""##REPETIDOR"""

df_r.REPETIDOR.value_counts().sort_values(ascending=False)   #mal informada no se tiene en cuenta......

df_r.REPETIDOR.unique()

df_r.REPETIDOR.nunique()

df_r.REPETIDOR.value_counts(normalize=True).sort_values(ascending=False)

df_r.REPETIDOR.value_counts().sum()

tabla_frec_REPETIDOR = df_r['REPETIDOR'].value_counts().reset_index()
tabla_frec_REPETIDOR.columns = ['REPETIDOR', 'Frecuencia']

tabla_frec_REPETIDOR.dtypes

tabla_frec_REPETIDOR.loc[tabla_frec_REPETIDOR["REPETIDOR"]=="", "REPETIDOR"]= 2

tabla_frec_REPETIDOR

sns.set()
colores=["blue","red","green"]
ax=plt.bar(tabla_frec_REPETIDOR['REPETIDOR'], tabla_frec_REPETIDOR['Frecuencia'], color = colores)
ax=plt.tick_params(axis='both', labelsize=10)
plt.xlabel('REPETIDOR')
plt.xticks([0,1],rotation=0)
plt.ylabel('Frecuencia')
plt.title('Distribución de REPETIDOR')
plt.show()

"""##MANTENER_HIST"""

df_r.MANTENER_HIST.value_counts()

df_r.MANTENER_HIST.value_counts(normalize=True)

df_r.MANTENER_HIST.unique()

tabla_frec_HIST = df_r['MANTENER_HIST'].value_counts().reset_index()
tabla_frec_HIST.columns = ['MANTENER_HIST', 'Frecuencia']

tabla_frec_HIST

sns.set()
colores=["blue","red"]
ax=plt.bar(tabla_frec_HIST['MANTENER_HIST'], tabla_frec_HIST['Frecuencia'], color = colores)
ax=plt.tick_params(axis='both', labelsize=10)
plt.xlabel('HISTORICO')
plt.xticks([0,1],rotation=0)
plt.ylabel('Frecuencia')
plt.title('Distribución de MANTENER_HISTORICO')
plt.show()

"""##ID_MOTIVO"""

df_r.ID_MOTIVO.unique()                 #pendiente conocer el motivo asociado a cada código...variables, id_motivo y motivo que se usarán en las acciones de marketing

df_r.ID_MOTIVO.value_counts()



"""##SUPLETORIA"""

df_r.SUPLETORIA.unique()

"""##CUNAS"""

df_r.CUNAS.unique()

"""##FECHA_TOMA FECHA_TTOO FECHA_MOD"""

df_r['FECHA_TOMA'] = pd.to_datetime(df_r['FECHA_TOMA'])  # Convertir la columna a tipo datetime
df_r['FECHA_MOD'] = pd.to_datetime(df_r['FECHA_MOD'])    #esta fecha queda "congelada" para las reservas canceladas
df_r['FECHA_TTOO'] = pd.to_datetime(df_r['FECHA_TTOO'])

df_r['ANYO_MES_TOMA'] = df_r['FECHA_TOMA'].dt.strftime('%B %Y')  # Obtener el formato mes año
df_r['ANYO_MES_MOD'] = df_r['FECHA_MOD'].dt.strftime('%B %Y')
df_r['ANYO_MES_TTOO'] = df_r['FECHA_TTOO'].dt.strftime('%B %Y')

df_r['MES_TOMA'] = df_r['FECHA_TOMA'].dt.strftime('%B')  # Obtener el formato mes
df_r['MES_MOD'] = df_r['FECHA_MOD'].dt.strftime('%B')
df_r['MES_TTOO'] = df_r['FECHA_TTOO'].dt.strftime('%B')



df_r.head()

max_fecha_toma = df_r['FECHA_TOMA'].max()
max_fecha_ttoo = df_r['FECHA_TTOO'].max()
max_fecha_mod = df_r['FECHA_MOD'].max()

print("Valor máximo de FECHA_TOMA:", max_fecha_toma)
print("Valor máximo de FECHA_TTOO:", max_fecha_ttoo)
print("Valor máximo de FECHA_MOD:", max_fecha_mod)

"""##LEAD TIME. Es el período de tiempo que transcurre entre el momento de la reserva y la fecha de llegada del cliente, o check-in.
Calcular lead time (Días entre fecha de llegada y fecha toma/ttoo).
Crear variable categórica para agrupar:

*   1 día
*   2 - 7 días
*   8 - 15 días
*   16 - 30 días
*   +30 días





"""

df_r["LEAD_TIME"] = (df_r["LLEGADA"] - df_r["FECHA_TTOO"]).dt.days
df_r.loc[0:10,["LLEGADA", "FECHA_TTOO","LEAD_TIME"]]

def asignar_lead_time_group(lead_time):
    if lead_time == 1:
        return "1_dia"
    elif 2 <= lead_time <= 7:
        return "2_a_7_dias"
    elif 8 <= lead_time <= 15:
        return "8_a_15_dias"
    elif 16 <= lead_time <= 30:
        return "16_a_30_dias"
    elif 31 <= lead_time <= 60:
      return "31_a_60_dias"
    elif 61 <= lead_time <= 90:
      return "61_a_90_dias"
    elif 91 <= lead_time <= 120:
      return "91_a_120_dias"
    elif 121 <= lead_time <= 180:
      return "121_a_180_dias"
    elif 181 <= lead_time <= 360:
      return "181_a_360_dias"
    else:
        return "+360_dias"

# Crear la nueva columna "LEAD_TIME_GROUP" aplicando la función a la columna "LEAD_TIME"
df_r["LEAD_TIME_GROUP"] = df_r["LEAD_TIME"].apply(asignar_lead_time_group)

# Mostrar el DataFrame con la nueva columna
df_r.head()

df_r["LEAD_TIME_GROUP"].value_counts()

tabla_frec_LEAD_TIME = df_r['LEAD_TIME_GROUP'].value_counts().reset_index()
tabla_frec_LEAD_TIME.columns = ['LEAD_TIME_GROUP', 'Frecuencia']

tabla_frec_LEAD_TIME

tabla_frec_LEAD_TIME_n = df_r['LEAD_TIME_GROUP'].value_counts(normalize=True).reset_index()
tabla_frec_LEAD_TIME_n.columns = ['LEAD_TIME_GROUP', 'Frecuencia']

tabla_frec_LEAD_TIME_n

ax=sns.barplot(x=tabla_frec_LEAD_TIME["LEAD_TIME_GROUP"], y=tabla_frec_LEAD_TIME['Frecuencia'], data=tabla_frec_LEAD_TIME)
#ax.set_yscale('log')
plt.tick_params(axis='both', labelsize=10)
plt.xlabel("LEAD_TIME_GROUP")
plt.xticks(rotation=90)
plt.ylabel('Frecuencia')
plt.title("Distribución LEAD_TIME_GROUP en reservas")

ax=sns.barplot(x=tabla_frec_LEAD_TIME_n["LEAD_TIME_GROUP"], y=tabla_frec_LEAD_TIME_n['Frecuencia'], data=tabla_frec_LEAD_TIME_n)
#ax.set_yscale('log')
plt.tick_params(axis='both', labelsize=10)
plt.xlabel("LEAD_TIME_GROUP")
plt.xticks(rotation=90)
plt.ylabel('Frecuencia relativa')
plt.title("Distribución LEAD_TIME_GROUP en reservas")

cross_LT_C_n = pd.crosstab(df_r['LEAD_TIME_GROUP'], df_r['CANCELACION'],normalize = True)
cross_LT_C_n

cross_LT_C = pd.crosstab(df_r['LEAD_TIME_GROUP'], df_r['CANCELACION'],normalize = False)
cross_LT_C

plt.figure(figsize=(20,20))
cross_LT_C.plot(kind='bar', stacked=False)

plt.xlabel('LEAD_TIME_GROUP')
plt.xticks(rotation=90, fontsize=10)
plt.ylabel('Frecuencia')
plt.title('Ditribucion de reservas efectivas/canceladas por LEAD_TIME_GROUP')
plt.show()

plt.figure(figsize=(20,20))
cross_LT_C_n.plot(kind='bar', stacked=False)

plt.xlabel('LEAD_TIME_GROUP')
plt.xticks(rotation=90, fontsize=10)
plt.ylabel('Frecuencia relativa')
plt.title('Ditribucion de reservas efectivas/canceladas por LEAD_TIME_GROUP')
plt.show()

"""##SEGMENTO"""

df_r.SEGMENTO.unique()            #no la usamos en el modelo

"""##FUENTE"""

df_r.FUENTE.unique() #no la usamos en el modelo

"""##ATENCION
No se usará para el modelo. Lo dejamos para las posibles acciones de MKT
"""

df_r.ATENCION.unique()

"""##MONEDA"""

moneda_counts = df_r['MONEDA'].value_counts()
moneda_counts

moneda_counts_n = df_r['MONEDA'].value_counts(normalize=True)
moneda_counts_n

moneda_counts = df_r['MONEDA'].value_counts()
plt.figure(figsize=(8, 6))
sns.barplot(x=moneda_counts.index, y=moneda_counts.values)
plt.title('Distribución de MONEDA')
plt.xlabel('MONEDA')
plt.ylabel('Conteo')
plt.show()

moneda_counts_n = df_r['MONEDA'].value_counts(normalize=True)
plt.figure(figsize=(8, 6))
sns.barplot(x=moneda_counts_n.index, y=moneda_counts_n.values)
plt.title('Distribución de MONEDA')
plt.xlabel('MONEDA')
plt.ylabel('% Conteo')
plt.show()

cross_M_C = pd.crosstab(df_r['MONEDA'], df_r['CANCELACION'],normalize = False)
cross_M_C

cross_M_C_n = pd.crosstab(df_r['MONEDA'], df_r['CANCELACION'],normalize = True)
cross_M_C_n

plt.figure(figsize=(20,20))
cross_M_C.plot(kind='bar', stacked=False)

plt.xlabel('MONEDA')
plt.xticks(rotation=45, fontsize=10)
plt.ylabel('Frecuencia')
plt.title('Ditribucion de reservas efectivas/canceladas por MONEDA')
plt.show()

plt.figure(figsize=(20,20))
cross_M_C_n.plot(kind='bar', stacked=False)

plt.xlabel('MONEDA')
plt.xticks(rotation=45, fontsize=10)
plt.ylabel('Frecuencia relativa')
plt.title('Ditribucion de reservas efectivas/canceladas por MONEDA')
plt.show()

!pip install unidecode
from unidecode import unidecode
df_r["MONEDA"] = df_r["MONEDA"].apply(unidecode)   #para quitar las tildes

df_r["MONEDA"].value_counts()

"""##STATUS"""

status_counts = df_r['STATUS'].value_counts()
plt.figure(figsize=(8, 6))
sns.barplot(x=status_counts.index, y=status_counts.values)
plt.title('Distribución de STATUS')
plt.xlabel('STATUS')
plt.ylabel('Conteo')
plt.show()

"""##CANCELACION Y RESERVA SEGUN FECHAS"""

df_cancelacion = df_r[df_r['CANCELACION'] == 1]
conteo_cancelacion = df_cancelacion.groupby(df_cancelacion['FECHA_TOMA'].dt.to_period('M')).size()
conteo_cancelacion_modificacion = df_cancelacion.groupby(df_cancelacion['FECHA_MOD'].dt.to_period('M')).size()
conteo_cancelacion_ttoo = df_cancelacion.groupby(df_cancelacion['FECHA_TTOO'].dt.to_period('M')).size()

conteo_cancelacion.sort_values(ascending=False)    #de las reservas canceladas del data set, frecuencia absoluta fecha toma

conteo_cancelacion.values

conteo_cancelacion_modificacion.sort_values(ascending=False)

conteo_cancelacion_ttoo.sort_values(ascending=False)

plt.figure(figsize=(12, 6))
sns.barplot(x=conteo_cancelacion.index, y=conteo_cancelacion.values)
plt.title('Conteo de reservas canceladas por mes y año' )
plt.xlabel('Mes/Año de Toma')
plt.ylabel('Conteo de Reservas Canceladas')
plt.xticks(rotation=90)
plt.show()

plt.figure(figsize=(12, 6))
sns.barplot(x=conteo_cancelacion_modificacion.index, y=conteo_cancelacion_modificacion.values)
plt.title('Conteo de reservas modificadas por mes y año ')
plt.xlabel('Mes/Año de Modificación')
plt.ylabel('Conteo de Reservas Canceladas')
plt.xticks(rotation=90)
plt.show()

plt.figure(figsize=(12, 6))
sns.barplot(x=conteo_cancelacion_ttoo.index, y=conteo_cancelacion_ttoo.values)
plt.title('Conteo de reservas canceladas por mes y año ')
plt.xlabel('Mes/Año TTOO')
plt.ylabel('Conteo de Reservas TTOO')
plt.xticks(rotation=90)
plt.show()

df_no_cancelacion = df_r[df_r['CANCELACION'] == 0]
conteo_no_cancelacion = df_no_cancelacion.groupby(df_no_cancelacion['FECHA_TOMA'].dt.to_period('M')).size()
conteo_no_cancelacion_modificacion = df_no_cancelacion.groupby(df_no_cancelacion['FECHA_MOD'].dt.to_period('M')).size()
conteo_no_cancelacion_ttoo = df_no_cancelacion.groupby(df_no_cancelacion['FECHA_TTOO'].dt.to_period('M')).size()

conteo_no_cancelacion.sort_values(ascending=False)    #fecha de TOMA

conteo_no_cancelacion_modificacion.sort_values(ascending=False)

conteo_no_cancelacion_ttoo.sort_values(ascending=False)

conteo_toma = df_r['FECHA_TOMA'].dt.to_period('M').value_counts().sort_index()    #todas las reservas.....
conteo_mod = df_r['FECHA_MOD'].dt.to_period('M').value_counts().sort_index()
conteo_ttoo = df_r['FECHA_TTOO'].dt.to_period('M').value_counts().sort_index()

conteo_toma.sort_values(ascending=False)

conteo_mod.sort_values(ascending=False)

conteo_ttoo.sort_values(ascending=False)

plt.figure(figsize=(12, 6))
sns.barplot(x=conteo_toma.index, y=conteo_toma.values)
plt.title('Conteo de reservas por fecha toma')
plt.xlabel('Mes/Año toma')
plt.ylabel('Conteo de Reservas')
plt.xticks(rotation=45)
plt.show()

plt.figure(figsize=(12, 6))
sns.barplot(x=conteo_ttoo.index, y=conteo_ttoo.values)
plt.title('Conteo de reservas por fecha ttoo')
plt.xlabel('Mes/Año ttoo')
plt.ylabel('Conteo de Reservas')
plt.xticks(rotation=45)
plt.show()

plt.figure(figsize=(12, 6))
sns.barplot(x=conteo_mod.index, y=conteo_mod.values)
plt.title('Conteo de reservas por fecha mod')
plt.xlabel('Mes/Año mod')
plt.ylabel('Conteo de Reservas')
plt.xticks(rotation=45)
plt.show()

df_r.loc[0:5,["FIDELIDAD",	"NUMSOCIO",	"SEGMENTOCREDITO",	"TRATO",	"PAIS",	"VALHAB",	"VALPEN",	"VALSERV",	"VALFIJOS",	"COMERCIALIZADORA",	"CM_ID_CONTRATO",	"CM_CONTRATO",	"CMVALHAB",	"CMVALPEN",	"CMCVALSERV",	"REGFACTURA",	"GRATIS",	"VIAJACON",	"CUPO",	"TIPODOCUMENTO"]]

"""##FIDELIDAD"""

df_r.FIDELIDAD.value_counts()

"""##ID_PAGO"""

df_r.ID_PAGO.value_counts()            #pendiente EDA, 1 pago_desglosado (parte_inicial_resto_llegada_hotel),   2 pago_directo_hotel  3 tarjta(full-credit)????

"""##Creamos una nueva variable TIPO_PAGO"""

df_r["TIPO_PAGO"]='PAGO DIRECTO'

df_r.loc[df_r['ID_PAGO']==1,"TIPO_PAGO"]='DESGLOSE'
df_r.loc[df_r['ID_PAGO']==3,"TIPO_PAGO"]='FULL CREDIT'

serie_tipo_pago= df_r.TIPO_PAGO.value_counts()
serie_tipo_pago

serie_tipo_pago_n= df_r.TIPO_PAGO.value_counts(normalize=True)
serie_tipo_pago_n

plt.figure(figsize=(8, 6))
sns.barplot(x= serie_tipo_pago.index, y= serie_tipo_pago.values)
plt.title('Distribución de TIPO_PAGO')
plt.xlabel('TIPO_PAGO')
plt.ylabel('Frecuencia')
plt.show()

plt.figure(figsize=(8, 6))
sns.barplot(x= serie_tipo_pago_n.index, y= serie_tipo_pago_n.values)
plt.title('Distribución de TIPO_PAGO')
plt.xlabel('TIPO_PAGO')
plt.ylabel('Frecuencia relativa')
plt.show()

cross_TP_C = pd.crosstab(df_r['TIPO_PAGO'], df_r['CANCELACION'],normalize = False)
cross_TP_C

cross_TP_C_n = pd.crosstab(df_r['TIPO_PAGO'], df_r['CANCELACION'],normalize = True)
cross_TP_C_n

plt.figure(figsize=(20,20))
cross_TP_C_n.plot(kind='bar', stacked=False)

plt.xlabel('TIPO_CLIENTE')
plt.xticks(rotation=90, fontsize=10)
plt.ylabel('Frecuencia relativa')
plt.title('Ditribucion de reservas efectivas/canceladas por TIPO_CLIENTE')
plt.show()

plt.figure(figsize=(20,20))
cross_TP_C.plot(kind='bar', stacked=False)

plt.xlabel('TIPO_CLIENTE')
plt.xticks(rotation=90, fontsize=10)
plt.ylabel('Frecuencia')
plt.title('Ditribucion de reservas efectivas/canceladas por TIPO_CLIENTE')
plt.show()

df_r.shape

"""##SEGMENTOCREDITO"""

df_r.SEGMENTOCREDITO.value_counts()           #como una especie de tarjeta de credito para pagar su estancia"

df_r.SEGMENTOCREDITO.value_counts(normalize=True).sort_values(ascending=False)

tabla_creditos = df_r['SEGMENTOCREDITO'].value_counts().reset_index()
tabla_creditos.columns = ['Tipo crédito', 'Nº Clientes']
tabla_creditos

tabla_creditos_n = df_r['SEGMENTOCREDITO'].value_counts(normalize=True).reset_index()
tabla_creditos_n.columns = ['Tipo crédito', 'Nº Clientes']
tabla_creditos_n

sns.set()
plt.bar(tabla_creditos['Tipo crédito'], tabla_creditos['Nº Clientes'])
plt.xlabel('Tipo crédito')
plt.xticks(rotation=45)
plt.ylabel('Frecuencia')
plt.title('Créditos clientes')
plt.show()

sns.set()
plt.bar(tabla_creditos_n['Tipo crédito'], tabla_creditos_n['Nº Clientes'])
plt.xlabel('Tipo crédito')
plt.xticks(rotation=45)
plt.ylabel('Frecuencia relativa')
plt.title('Créditos clientes')
plt.show()

cross_CR_C_n = pd.crosstab(df_r['SEGMENTOCREDITO'], df_r['CANCELACION'],normalize = True)
cross_CR_C_n

plt.figure(figsize=(20,20))
cross_CR_C_n.plot(kind='bar', stacked=False)

plt.xlabel('SEGMENTOCREDITO')
plt.xticks(rotation=0, fontsize=10)
plt.ylabel('Frecuencia relativa')
plt.title('Ditribucion de reservas efectivas/canceladas por SEGMENTOCREDITO')
plt.show()

cross_CR_C = pd.crosstab(df_r['SEGMENTOCREDITO'], df_r['CANCELACION'],normalize = False)
cross_CR_C

plt.figure(figsize=(20,20))
cross_CR_C.plot(kind='bar', stacked=False)

plt.xlabel('SEGMENTOCREDITO')
plt.xticks(rotation=0, fontsize=10)
plt.ylabel('Frecuencia')
plt.title('Ditribucion de reservas efectivas/canceladas por SEGMENTOCREDITO')
plt.show()

"""##PAIS"""

serie_p = df_r.PAIS.value_counts()
serie_p

serie_p.index

filtro= serie_p[serie_p>=8000]
filtro

#Cambio todo a mayúsculas, quito tildes y sustituyo los espacios blancos por SIN PAIS
!pip install unidecode
from unidecode import unidecode

df_r["PAIS"] = df_r["PAIS"].fillna("SIN PAIS").astype(str)
df_r["PAIS"] = df_r["PAIS"].str.upper()
df_r["PAIS"] = df_r["PAIS"].apply(unidecode)

df_r['PAIS'].value_counts()

top_paises = df_r['PAIS'].value_counts().nlargest(7).index.tolist() #Creo que una lista de paises top

#df_r['PAISES_AGRUPADOS'] =df_r['PAIS'].apply(lambda x: x if x in top_paises else 'OTROS') #Creo nueva columna que se compone del nombre de los top paises, los SIN PAIS y los paises no top como OTROS

#df_r.loc[0:80,["PAIS","PAISES_AGRUPADOS"]]
top_paises

df_r['PAISES_AGRUPADOS'] = df_r['PAIS'].apply(lambda x: x if x in top_paises else 'OTROS') #Creo nueva columna que se compone del nombre de los top paises, los SIN PAIS y los paises no top como OTROS

df_r.loc[0:80,["PAIS","PAISES_AGRUPADOS"]]

df_r.loc[df_r.PAISES_AGRUPADOS == "OTROS", "PAIS"]   #quiero que de las filas con paises_agrupados igual a otros, dame el valor d ela columna PAIS

df_r.loc[df_r.PAISES_AGRUPADOS == "OTROS", "PAIS"].unique()

df_r.loc[df_r.PAISES_AGRUPADOS == "OTROS", "PAIS"].nunique()

df_r.loc[df_r.PAISES_AGRUPADOS == "OTROS", "PAIS"].value_counts()

df_r['PAISES_AGRUPADOS'].value_counts()    #Qué hacemos con SIN PAIS????. Crear variable transoceánica, si, no...

df_r['PAISES_AGRUPADOS'].value_counts(normalize=True)

tabla_paises = df_r['PAISES_AGRUPADOS'].value_counts().reset_index()
tabla_paises.columns = ['PAISES_AGRUPADOS', 'Frecuencia']
tabla_paises

tabla_paises_n = df_r['PAISES_AGRUPADOS'].value_counts(normalize=True).reset_index()
tabla_paises_n.columns = ['PAISES_AGRUPADOS', 'Frecuencia']
tabla_paises_n

cross_P_C = pd.crosstab(df_r['PAISES_AGRUPADOS'], df_r['CANCELACION'],normalize = False)
cross_P_C

cross_P_C_n = pd.crosstab(df_r['PAISES_AGRUPADOS'], df_r['CANCELACION'],normalize = True)
cross_P_C_n

sns.set()
plt.bar(tabla_paises['PAISES_AGRUPADOS'], tabla_paises['Frecuencia'])
plt.xlabel('Paises_Agrupados')
plt.xticks(rotation=90)
plt.ylabel('Frecuencia')
plt.title('Paises_Agrupados')
plt.show()

sns.set()
plt.bar(tabla_paises_n['PAISES_AGRUPADOS'], tabla_paises_n['Frecuencia'])
plt.xlabel('Paises_Agrupados')
plt.xticks(rotation=90)
plt.ylabel('Frecuencia relativa')
plt.title('Paises_Agrupados')
plt.show()

plt.figure(figsize=(20,20))
cross_P_C.plot(kind='bar', stacked=False)

plt.xlabel('PAISES_AGRUPADOS')
plt.xticks(rotation=90, fontsize=10)
plt.ylabel('Frecuencia')
plt.title('Ditribucion de reservas efectivas/canceladas por PAISES_AGRUPADOS')
plt.show()

plt.figure(figsize=(20,20))
cross_P_C_n.plot(kind='bar', stacked=False)

plt.xlabel('PAISES_AGRUPADOS')
plt.xticks(rotation=90, fontsize=10)
plt.ylabel('Frecuencia relativa')
plt.title('Ditribucion de reservas efectivas/canceladas por PAISES_AGRUPADOS')
plt.show()

df_r.head()

df_r.loc[df_r.PAISES_AGRUPADOS == "OTROS", "PAIS"].unique()

"""##Crear variables TRANSOCEANICA, suponemos que si el país/isla de origen está en el mismo continente que los Hoteles tomará valor cero y de lo contrario será uno."""

paises_islas_America =['ARGENTINA', 'PERU', 'URUGUAY', 'COLOMBIA', 'PUERTO RICO',
       'COSTA RICA', 'VENEZUELA', 'CHILE', 'JAMAICA', 'BOLIVIA',
       'HAITI', 'EL SALVADOR', 'BAHAMAS', 'ARUBA', 'PARAGUAY', 'BARBADOS','BELICE',
       'CUBA', 'DOMINICA', 'NICARAGUA', 'HONDURAS','PANAMA', 'SAMOA','MARTINICA', 'GUAYANA', 'GUATEMALA', 'TRINIDAD Y TOBAGO', 'ECUADOR',
       'ANTIGUA Y BARBUDA', 'BERMUDAS', 'SANTA LUCIA', 'ANTILLAS NEERLANDESAS', 'GUAYANA FRANCESA', 'SAN VICENTE Y LAS GRANADINAS', 'SURINAM', 'GRANADA', 'GUADALUPE', 'SAMOA AMERICANA']

df_r['TRANSOCEANICO'] = 1      #revisar, en otros hay muchos paises de America......
df_r.loc[df_r["PAIS"].isin (paises_islas_America), "TRANSOCEANICO"]= 0

df_r.TRANSOCEANICO.value_counts()

tabla_transo = df_r['TRANSOCEANICO'].value_counts().reset_index()
tabla_transo.columns = ['TRANSOCEANICO', 'Frecuencia']
tabla_transo

tabla_transo.columns

tabla_transo_n = df_r['TRANSOCEANICO'].value_counts(normalize=True).reset_index()
tabla_transo_n.columns = ['TRANSOCEANICO', 'Frecuencia']
tabla_transo_n

cross_TRO_C = pd.crosstab(df_r['TRANSOCEANICO'], df_r['CANCELACION'],normalize = False)
cross_TRO_C

cross_TRO_C_n = pd.crosstab(df_r['TRANSOCEANICO'], df_r['CANCELACION'],normalize = True)
cross_TRO_C_n

sns.set()
plt.bar(tabla_transo["TRANSOCEANICO"], tabla_transo['Frecuencia'])
plt.xlabel('TRANSOCEANICO')
plt.xticks([0,1],rotation=0)
plt.ylabel('Frecuencia')
plt.title('Reservas procedentes de paises transoceánicos')
plt.show()

sns.set()
plt.bar(tabla_transo_n["TRANSOCEANICO"], tabla_transo_n['Frecuencia'])
plt.xlabel('TRANSOCEANICO')
plt.xticks([0,1],rotation=0)
plt.ylabel('Frecuencia relativa')
plt.title('Reservas procedentes de paises transoceánicos')
plt.show()

plt.figure(figsize=(20,20))
cross_TRO_C.plot(kind='bar', stacked=False)

plt.xlabel('TRANSOCEANICO')
plt.xticks([0,1],rotation=0, fontsize=10)
plt.ylabel(' Frecuencia')
plt.title('Ditribucion de reservas efectivas/canceladas')
plt.show()

plt.figure(figsize=(20,20))
cross_TRO_C_n.plot(kind='bar', stacked=False)

plt.xlabel('TRANSOCEANICO')
plt.xticks(rotation=90, fontsize=10)
plt.ylabel('Frecuencia relativa')
plt.title('Ditribucion de reservas efectivas/canceladas')
plt.show()

plt.figure(figsize=(20,20))
cross_P_C_n.plot(kind='bar', stacked=False)

plt.xlabel('PAISES_AGRUPADOS')
plt.xticks(rotation=90, fontsize=10)
plt.ylabel('Frecuencia relativa')
plt.title('Ditribucion de reservas efectivas/canceladas por PAISES_AGRUPADOS')
plt.show()

"""## MULTIPLE"""

df_r.MULTIPLE.value_counts() #Confirmar con Gustavo esta variable. 0 = Grupo / 1 = NO GRUPO ¿?¿?¿?

df_r.ID_MULTIPLE.value_counts()      #ID MULTIPLE O Y RESTO 1 (Grupo)

df_r['TIPO_MULTIPLE'] = 'GRUPO'    #pendiente EDA......
df_r.loc[df_r['ID_MULTIPLE']==0,"TIPO_MULTIPLE"]='NO GRUPO'
df_r.TIPO_MULTIPLE.value_counts()

"""##CONTRATO"""

df_r.CM_CONTRATO.value_counts()[0:10] #A DESTACAR: REBOOKING COVID, CONTRATO ESPECIAL_COVID

filtro_REBOOKING = df_r[df_r["CM_CONTRATO"].str.contains("REBOOKING", na=False)]
filtro_ESPECIAL_COVID = df_r[df_r["CM_CONTRATO"].str.contains("ESPECIAL_COVID", na=False)]

cantidad_REBOOKING = len(filtro_REBOOKING)
cantidad_ESPECIAL_COVID = len(filtro_ESPECIAL_COVID)

print("Total Contratos tipo REBOOKING COVID", cantidad_REBOOKING)
print("Total Contratos tipo ESPECIAL COVID", cantidad_ESPECIAL_COVID)

"""##VALORES RESERVA"""

info_valores = ['VALHAB', 'VALPEN', 'VALSERV', 'VALFIJOS', 'CMVALHAB', 'CMVALPEN', 'CMCVALSERV']
info_valores = df_r[info_valores]
info_valores.info()

pd.set_option('display.float_format', '{:.2f}'.format)
variables_seleccionadas = ['VALHAB', 'VALPEN', 'VALSERV', 'VALFIJOS', 'CMVALHAB', 'CMVALPEN', 'CMCVALSERV']
variables_valores = df_r[variables_seleccionadas]
variables_valores = variables_valores.astype(float)
variables_valores.describe()

"""REVISAR LAS DOS VARIABLES DE TOTAL_VALUES Y CM_TOTAL_VALUES"""

df_r['TOTAL_VALUES'] = df_r['VALHAB'] + df_r['VALPEN'] + df_r['VALSERV'] + df_r['VALFIJOS'] # Nueva variable del valor total del coste de las habitaciones + servicios etc
df_r['CM_TOTAL_VALUES'] = df_r['CMVALHAB'] + df_r['CMVALPEN'] + df_r['CMCVALSERV'] # Nueva variable del valor total del coste de las habitaciones + servicios etc de los CM
df_r.loc[0:20,['COMERCIALIZADORA','VALHAB', 'VALPEN', 'VALSERV', 'VALFIJOS', 'CMVALHAB', 'CMVALPEN', 'CMCVALSERV', 'TOTAL_VALUES', 'CM_TOTAL_VALUES']]

df_r[["TOTAL_VALUES","CM_TOTAL_VALUES"]][0:50]

valores_negativos = df_r[(df_r['VALHAB'] < 0) & (df_r['COMERCIALIZADORA'] == 0)]
valores_negativos.head(30)

valores_negativos = df_r[(df_r['CMVALHAB'] < 0) & (df_r['COMERCIALIZADORA'] == 1)]
valores_negativos.tail(30)

valores_negativos = df_r[(df_r['VALFIJOS'] < 0) & (df_r['COMERCIALIZADORA'] == 0)]
valores_negativos.head(30)

"""Casuística:

Hay valoares negativos que no se muy bien que significan. Lo que he visto es:

Si la comercializadora es igual a 0 los valores que necesitamos son VALHAB etc:

Cuando la variable VALHAB está en negativo el mismo importe está en positivo en la variables VALPEN

![image.png](data:image/png;base64,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)

Si la comercializadora es igual a 1 los valores que necesitamos son CMVALHAB etc:

Pasa lo mismo, cuando la variable CMVAHAB está en negativo, la variable CMVALPEN tiene exactamente el mismo importe en positivo

![image.png](data:image/png;base64,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)

Por lo que creo que debemos cambiar el valor de las variables VALHAB y CMVALHAB = 0 para que no trastoque las columnas del Total Value y CM Total Value

Pero también se da el caso donde el valor negativo de CMVALHAB si se resta al valor CNVALPEN es = al valor de VALHAB, son pocos los casos:

![image.png](data:image/png;base64,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)

Por otro lado, la variable VALFIJOS también tiene valores en negativo

![image.png](data:image/png;base64,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)



Tiene pinta de que se trate de descuentos, pero sería bueno confirmarlo con Gustavo
"""

valores_negativos_2 = df_r[(df_r['TOTAL_VALUES'] == 0) | (df_r['TOTAL_VALUES'] < 0) & (df_r['COMERCIALIZADORA'] == 0)]
valores_negativos_2.head(30)

valores_negativos_2 = df_r[(df_r['CM_TOTAL_VALUES'] == 0) & (df_r['COMERCIALIZADORA'] == 1)]
valores_negativos_2.tail(30)

"""Si hago lo que dijo gustavo....sumar las cuatro variables de los valores. Para los casos que tenían la VARHAB en negativo, la nueva columna va a quedar a cero....Quizá no le entendí bien"""

df_r.columns

# Función valores (Total Values, CM Total Values) que debe tener enc uenta dependiendo si el CM es = 0 o 1
def seleccionar_valores(row):
  if row['COMERCIALIZADORA'] == 1:
    return row['CM_TOTAL_VALUES']
  else:
    return row['TOTAL_VALUES']

df_r['VALUES'] = df_r.apply(seleccionar_valores, axis=1)

df_r.loc[0:20,['COMERCIALIZADORA', "TOTAL_VALUES","CM_TOTAL_VALUES","VALUES"]]

#df_r["VALUES"]= df_r["TOTAL_VALUES"]

#df_r.loc[df_r.COMERCIALIZADORA==1, "VALUES"]= df_r["CM_TOTAL_VALUES"]

df_r.loc[0:20,['COMERCIALIZADORA', "TOTAL_VALUES","CM_TOTAL_VALUES","VALUES"]]

#df_r.loc[df_r.COMERCIALIZADORA==1, "VALUES"]= df_r["CM_TOTAL_VALUES"]
df_r.loc[df_r.VALUES==0,['COMERCIALIZADORA', "TOTAL_VALUES","CM_TOTAL_VALUES","VALUES"]][0:10]

len(df_r.loc[df_r.VALUES==0])

len(df_r.loc[df_r["VALUES"]!=0])

df_r.shape[0]

#no tiene lógica de negocio y los vamos a quitar en principio....

df_r= df_r.loc[df_r["VALUES"]!=0,:]
len(df_r)

#Comprobación función anterior
conteo_no_comercializadora = df_r[df_r['COMERCIALIZADORA'] == 0]
conteo_comercializadora = df_r[df_r['COMERCIALIZADORA'] == 1]

conteo_no_comercializadora_1 = conteo_no_comercializadora['VALUES'].count()
conteo_comercializadora_1 = conteo_comercializadora['VALUES'].count()

print("Total filas no comercializadora", conteo_no_comercializadora_1)
print("Total filas comercializadora", conteo_comercializadora_1)

"""##MISMA MONEDA PARA TODAS LAS RESERVAS:
Vamos a poner los valores de la reserva (para comercializadora=0 y comercializadora=1), en una misma moneda, esto es, dólares. Hay una columna "VALUES" que tiene el valor de estas reservas pero en dólares, pesos mexicanos y reales brasileños...
"""

df_r["VALUE_DOLARES"] = 0

df_r.loc[df_r["MONEDA"]=="Dolar", "VALUE_DOLARES"]= df_r["VALUES"]

len(df_r.loc[df_r["MONEDA"]=="Dolar"])

df_r.loc[:,["MONEDA","VALUES", "VALUE_DOLARES"]][0:20]

df_r.loc[df_r["MONEDA"]=="Peso Mexicano", "VALUE_DOLARES"]= df_r["VALUES"]/20 #(tipo medio cambio en 2021)

df_r.loc[(df_r["MONEDA"]=="Peso Mexicano") & (df_r["VALUE_DOLARES"]!=0) ,["MONEDA","VALUES", "VALUE_DOLARES"]]

df_r.loc[df_r["MONEDA"]=="Real", "VALUE_DOLARES"]= df_r["VALUES"]/5.7

df_r["VALUE_DOLARES"].isna().sum()

len(df_r.loc[df_r.VALUE_DOLARES==0])

df_r.loc[df_r.VALUE_DOLARES<0]

len(df_r.loc[df_r.VALUE_DOLARES<0])

df_r["VALUE_DOLARES"].describe()

fig = px.box(df_r, y="VALUE_DOLARES")
fig.show()

fig = px.box(df_r, x="CANCELACION", y="VALUE_DOLARES")
fig.show()

"""##Creo que Gustavo nos dijo que supliesemos los valores negativos con la mediana, tanto para comercialzadora=0, como para comercializadora=1

"""

df_r.loc[(df_r["COMERCIALIZADORA"]==0) & (df_r["VALUE_DOLARES"]<0),"VALUE_DOLARES"]= df_r.loc[(df_r["COMERCIALIZADORA"]==0) , "VALUE_DOLARES"].median()
df_r.loc[(df_r["COMERCIALIZADORA"]==1) & (df_r["VALUE_DOLARES"]<0),"VALUE_DOLARES"]= df_r.loc[(df_r["COMERCIALIZADORA"]==1) ,"VALUE_DOLARES"].median()

df_r.loc[(df_r["COMERCIALIZADORA"]==1) ,"VALUE_DOLARES"].median()

df_r.loc[(df_r["COMERCIALIZADORA"]==0) , "VALUE_DOLARES"].median()

len(df_r.loc[(df_r["COMERCIALIZADORA"]==0) & (df_r["VALUE_DOLARES"] <0)])

len(df_r.loc[(df_r["COMERCIALIZADORA"]==1) & (df_r["VALUE_DOLARES"] <0)])

df_r["VALUE_DOLARES"].describe()

len(df_r.loc[(df_r["COMERCIALIZADORA"]==1) & (df_r["VALUE_DOLARES"] ==0)])

len(df_r.loc[(df_r["COMERCIALIZADORA"]==0) & (df_r["VALUE_DOLARES"] ==0)])

df_r.loc[df_r["VALUE_DOLARES"]==0,['COMERCIALIZADORA', 'NOCHES','VALHAB', 'VALPEN', 'VALSERV', 'VALFIJOS', 'CMVALHAB', 'CMVALPEN', 'CMCVALSERV','VALUE_DOLARES']][0:100]

fig = px.box(df_r, y="VALUE_DOLARES")
fig.show()

fig = px.box(df_r, x="CANCELACION", y="VALUE_DOLARES")
fig.show()

df_r["VALUE_DOLARES"].isna().sum()

"""## PRECIO MEDIO NOCHE:
Definimos una nueva variable que es el precio medio por noche de la siguiente forma:
"""

df_r["PRECIO_MEDIO_NOCHE_DOLARES"]= df_r["VALUE_DOLARES"]/df_r["NOCHES"]

df_r[["NOCHES", "VALUE_DOLARES", "PRECIO_MEDIO_NOCHE_DOLARES"]][0:20]

df_r.PRECIO_MEDIO_NOCHE_DOLARES.describe()

df_r.loc[df_r['PRECIO_MEDIO_NOCHE_DOLARES']==0,['VALUE_DOLARES']]

len(df_r[df_r['PRECIO_MEDIO_NOCHE_DOLARES']==0])

fig = px.box(df_r, y="PRECIO_MEDIO_NOCHE_DOLARES")
fig.show()

fig = px.box(df_r, x= "CANCELACION", y="PRECIO_MEDIO_NOCHE_DOLARES")
fig.show()

"""ELIMINAR OUTLIERS. Al observar el box plot podemos eliminar, en principio, las reservas con un precio mayor a 500 euros"""

df_r= df_r.loc[df_r['PRECIO_MEDIO_NOCHE_DOLARES']<=500,:]
df_r.shape



"""##COMERCIALIZADORA"""

df_r.COMERCIALIZADORA.value_counts()

"""##REGFACTURA Y REGIMEN"""

df_r.REGFACTURA.value_counts()

tabla_frec_REGFACTURA = df_r["REGFACTURA"].value_counts().reset_index()
tabla_frec_REGFACTURA.columns = ["REGFACTURA", "Frecuencia"]
tabla_frec_REGFACTURA

frecuencias_REGIMEN = df_r["REGIMEN"].value_counts()
frecuencias_REGFACTURA = df_r["REGFACTURA"].value_counts()

suma_REGIMEN = frecuencias_REGIMEN.sum()
suma_REGFACTURA = frecuencias_REGFACTURA.sum()

print("Total frencuencia variable REGIMEN", suma_REGIMEN)
print("Total frencuencia variable REGFACTURA", suma_REGFACTURA)

filas_nulos_vacios_regfactura = df_r[df_r['REGFACTURA'].isnull() | (df_r['REGFACTURA'] == '')]

cantidad_filas = len(filas_nulos_vacios_regfactura)

print(cantidad_filas)

"""Entiendo que los campos REGIMEN y REGFACTURA la frencuencia debería ser la misma. De todas formas, no creo que estas variables tengas mucha relevancia más que para business y acciones de marketing etc.
![image.png](data:image/png;base64,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)

##VIAJACON
"""

df_r.VIAJACON.value_counts()

filas_nulos_vacios_viajacon = df_r[df_r['VIAJACON'].isnull() | (df_r['VIAJACON'] == '')]

cantidad_filas_viajacon = len(filas_nulos_vacios_viajacon)

print("Total filas vacías/nulas", cantidad_filas_viajacon)

"""##CUPO"""

df_r.CUPO.value_counts()

"""##TIPODOCUMENTO"""

df_r.TIPODOCUMENTO.value_counts()

df_r.FIDELIDAD.value_counts()

df_r.describe()

"""#MODELO CATBOOST PARA STREAMLIT"""

!pip install catboost

import pandas as pd
from catboost import CatBoostClassifier
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score
import pickle

df_catboost_streamlit = df_m.loc[:,['ID_RESERVA','TOP_6_NAMES_HOTELS',
 'CANCELACION',
 'LLEGADA_MES_ANYO',
 'SALIDA_MES_ANYO',
 'LEAD_TIME_GROUP',
 'PAISES_AGRUPADOS']]
df_catboost_streamlit.head()

df_catboost_streamlit= df_catboost_streamlit.dropna()
df_catboost_streamlit.isna().sum()

# Definir las características (X) y la variable objetivo (y)
X = df_catboost_streamlit.drop(columns=['CANCELACION','ID_RESERVA'], axis=1)
y = df_catboost_streamlit['CANCELACION']

# Definir las columnas categóricas
categorical_columns = ['TOP_6_NAMES_HOTELS', 'LLEGADA_MES_ANYO', 'SALIDA_MES_ANYO', 'LEAD_TIME_GROUP', 'PAISES_AGRUPADOS']

# Dividir los datos en conjuntos de entrenamiento y prueba
X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

# Crear el modelo CatBoostClassifier
model_streamlit = CatBoostClassifier(iterations=300, depth=10, cat_features=categorical_columns, verbose=0)

X_train.shape,X_test.shape,y_train.shape,y_test.shape

X_train.columns

X_test.columns

y_test[0:30]

X_test[0:30]

Test= X_test.copy()
Test["y_test"]= y_test

Test[0:30]

# Entrenar el modelo
model_streamlit.fit(X_train, y_train)

feature_importance_streamlit = model_streamlit.feature_importances_

model_streamlit.get_n_features_in ()

model_streamlit.feature_names_

df = pd.DataFrame(X_train.columns)

df["Importance"]= model_streamlit.get_feature_importance().tolist()
df.head(25)
df.rename({0:"feature"}, axis=1, inplace=True)
df.head(25)

model_streamlit.get_feature_importance().tolist()

num_streamlit_features_selected = df.loc[df.Importance>1.0,:]
num_streamlit_features_selected

num_streamlit_features_selected["feature"]

df_s= num_streamlit_features_selected.sort_values(by ='Importance', ascending=False)
df_s

X_test.iloc[0,:]

model_streamlit.predict(X_test.iloc[0,:]), model_streamlit.predict_proba(X_test.iloc[0,:])

model_streamlit.predict_proba(X_test.iloc[0,:])[1]

# Realizar predicciones en los datos de prueba
y_pred_streamlit = model_streamlit.predict(X_test)
y_pred_proba_streamlit = model_streamlit.predict_proba(X_test)
y_pred_train_stramlit= model_streamlit.predict(X_train)

# Calcular la precisión del modelo
accuracy = accuracy_score(y_test, y_pred_streamlit)
accuracy_entr = accuracy_score(y_train,y_pred_train_stramlit)
print(f'Precisión del modelo_test: {accuracy:.2f}')
print(f'Precisión del modelo_train: {accuracy:.2f}')

y_test[0:10]

model_streamlit.predict_proba(X_test)[0:10]

model_streamlit.predict_proba(X_test)[:, 1][0:10]

Test["predictions"]= y_pred_streamlit
Test[0:10]

Test["Prob_CANCELACION"]= model_streamlit.predict_proba(X_test)[:, 1]
Test.head()

Test["Prob_NO_CANCELACION"]= model_streamlit.predict_proba(X_test)[:, 0]
Test.head()

"""## GUARDAR MODELO EN DISCO CON PICKLE"""

# Guardo modelo en el disco

with open("palladium_model_catboost.pkl", 'wb') as archivo:
    pickle.dump(model_streamlit, archivo)

#cargo el modelo guardado en disco
with open("palladium_model_catboost.pkl", 'rb') as archivo:
  loaded_model = pickle.load(archivo)   #para cargar el modelo entrenado

prediccion = loaded_model.predict(X_test[0:50])
prediccion

prediccion_proba=loaded_model.predict_proba(X_test[0:50])
prediccion_proba

pip freeze > requirements.txt